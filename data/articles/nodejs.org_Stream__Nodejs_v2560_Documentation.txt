Title: Stream | Node.js v25.6.0 Documentation
Source: https://nodejs.org/api/stream.html

Source Code: lib/stream.js

A stream is an abstract interface for working with streaming data in Node.js.
The node:stream module provides an API for implementing the stream interface.

There are many stream objects provided by Node.js. For instance, a
request to an HTTP server and process.stdout
are both stream instances.

Streams can be readable, writable, or both. All streams are instances of
EventEmitter.

To access the node:stream module:

The node:stream module is useful for creating new types of stream instances.
It is usually not necessary to use the node:stream module to consume streams.

This document contains two primary sections and a third section for notes. The
first section explains how to use existing streams within an application. The
second section explains how to create new types of streams.

There are four fundamental stream types within Node.js:

Additionally, this module includes the utility functions
stream.duplexPair(),
stream.pipeline(),
stream.finished()
stream.Readable.from(), and
stream.addAbortSignal().

The stream/promises API provides an alternative set of asynchronous utility
functions for streams that return Promise objects rather than using
callbacks. The API is accessible via require('node:stream/promises')
or require('node:stream').promises.

Add the end option, which can be set to false to prevent automatically closing the destination stream when the source ends.

Added in: v15.0.0

To use an AbortSignal, pass it inside an options object, as the last argument.
When the signal is aborted, destroy will be called on the underlying pipeline,
with an AbortError.

The pipeline API also supports async generators:

Remember to handle the signal argument passed into the async generator.
Especially in the case where the async generator is the source for the
pipeline (i.e. first argument) or the pipeline will never complete.

The pipeline API provides callback version:

Added support for ReadableStream and WritableStream.

The cleanup option was added.

Added in: v15.0.0

The finished API also provides a callback version.

stream.finished() leaves dangling event listeners (in particular
'error', 'end', 'finish' and 'close') after the returned promise is
resolved or rejected. The reason for this is so that unexpected 'error'
events (due to incorrect stream implementations) do not cause unexpected
crashes. If this is unwanted behavior then options.cleanup should be set to
true:

All streams created by Node.js APIs operate exclusively on strings, <Buffer>,
<TypedArray> and <DataView> objects:

It is possible, however, for stream
implementations to work with other types of JavaScript values (with the
exception of null, which serves a special purpose within streams).
Such streams are considered to operate in "object mode".

Stream instances are switched into object mode using the objectMode option
when the stream is created. Attempting to switch an existing stream into
object mode is not safe.

Both Writable and Readable streams will store data in an internal
buffer.

The amount of data potentially buffered depends on the highWaterMark option
passed into the stream's constructor. For normal streams, the highWaterMark
option specifies a total number of bytes. For streams operating
in object mode, the highWaterMark specifies a total number of objects. For
streams operating on (but not decoding) strings, the highWaterMark specifies
a total number of UTF-16 code units.

Data is buffered in Readable streams when the implementation calls
stream.push(chunk). If the consumer of the Stream does not
call stream.read(), the data will sit in the internal
queue until it is consumed.

Once the total size of the internal read buffer reaches the threshold specified
by highWaterMark, the stream will temporarily stop reading data from the
underlying resource until the data currently buffered can be consumed (that is,
the stream will stop calling the internal readable._read() method that is
used to fill the read buffer).

Data is buffered in Writable streams when the
writable.write(chunk) method is called repeatedly. While the
total size of the internal write buffer is below the threshold set by
highWaterMark, calls to writable.write() will return true. Once
the size of the internal buffer reaches or exceeds the highWaterMark, false
will be returned.

A key goal of the stream API, particularly the stream.pipe() method,
is to limit the buffering of data to acceptable levels such that sources and
destinations of differing speeds will not overwhelm the available memory.

The highWaterMark option is a threshold, not a limit: it dictates the amount
of data that a stream buffers before it stops asking for more data. It does not
enforce a strict memory limitation in general. Specific stream implementations
may choose to enforce stricter limits but doing so is optional.

Because Duplex and Transform streams are both Readable and
Writable, each maintains two separate internal buffers used for reading and
writing, allowing each side to operate independently of the other while
maintaining an appropriate and efficient flow of data. For example,
net.Socket instances are Duplex streams whose Readable side allows
consumption of data received from the socket and whose Writable side allows
writing data to the socket. Because data may be written to the socket at a
faster or slower rate than data is received, each side should
operate (and buffer) independently of the other.

The mechanics of the internal buffering are an internal implementation detail
and may be changed at any time. However, for certain advanced implementations,
the internal buffers can be retrieved using writable.writableBuffer or
readable.readableBuffer. Use of these undocumented properties is discouraged.

Almost all Node.js applications, no matter how simple, use streams in some
manner. The following is an example of using streams in a Node.js application
that implements an HTTP server:

Writable streams (such as res in the example) expose methods such as
write() and end() that are used to write data onto the stream.

Readable streams use the EventEmitter API for notifying application
code when data is available to be read off the stream. That available data can
be read from the stream in multiple ways.

Both Writable and Readable streams use the EventEmitter API in
various ways to communicate the current state of the stream.

Duplex and Transform streams are both Writable and
Readable.

Applications that are either writing data to or consuming data from a stream
are not required to implement the stream interfaces directly and will generally
have no reason to call require('node:stream').

Developers wishing to implement new types of streams should refer to the
section API for stream implementers.

Writable streams are an abstraction for a destination to which data is
written.

Examples of Writable streams include:

Some of these examples are actually Duplex streams that implement the
Writable interface.

All Writable streams implement the interface defined by the
stream.Writable class.

While specific instances of Writable streams may differ in various ways,
all Writable streams follow the same fundamental usage pattern as illustrated
in the example below:

Add emitClose option to specify if 'close' is emitted on destroy.

Added in: v0.9.4

The 'close' event is emitted when the stream and any of its underlying
resources (a file descriptor, for example) have been closed. The event indicates
that no more events will be emitted, and no further computation will occur.

A Writable stream will always emit the 'close' event if it is
created with the emitClose option.

If a call to stream.write(chunk) returns false, the
'drain' event will be emitted when it is appropriate to resume writing data
to the stream.

The 'error' event is emitted if an error occurred while writing or piping
data. The listener callback is passed a single Error argument when called.

The stream is closed when the 'error' event is emitted unless the
autoDestroy option was set to false when creating the
stream.

After 'error', no further events other than 'close' should be emitted
(including 'error' events).

The 'finish' event is emitted after the stream.end() method
has been called, and all data has been flushed to the underlying system.

The 'pipe' event is emitted when the stream.pipe() method is called on
a readable stream, adding this writable to its set of destinations.

The 'unpipe' event is emitted when the stream.unpipe() method is called
on a Readable stream, removing this Writable from its set of
destinations.

This is also emitted in case this Writable stream emits an error when a
Readable stream pipes into it.

The writable.cork() method forces all written data to be buffered in memory.
The buffered data will be flushed when either the stream.uncork() or
stream.end() methods are called.

The primary intent of writable.cork() is to accommodate a situation in which
several small chunks are written to the stream in rapid succession. Instead of
immediately forwarding them to the underlying destination, writable.cork()
buffers all the chunks until writable.uncork() is called, which will pass them
all to writable._writev(), if present. This prevents a head-of-line blocking
situation where data is being buffered while waiting for the first small chunk
to be processed. However, use of writable.cork() without implementing
writable._writev() may have an adverse effect on throughput.

See also: writable.uncork(), writable._writev().

Work as a no-op on a stream that has already been destroyed.

Added in: v8.0.0

Destroy the stream. Optionally emit an 'error' event, and emit a 'close'
event (unless emitClose is set to false). After this call, the writable
stream has ended and subsequent calls to write() or end() will result in
an ERR_STREAM_DESTROYED error.
This is a destructive and immediate way to destroy a stream. Previous calls to
write() may not have drained, and may trigger an ERR_STREAM_DESTROYED error.
Use end() instead of destroy if data should flush before close, or wait for
the 'drain' event before destroying the stream.

Once destroy() has been called any further calls will be a no-op and no
further errors except from _destroy() may be emitted as 'error'.

Implementors should not override this method,
but instead implement writable._destroy().

Is true after 'close' has been emitted.

Is true after writable.destroy() has been called.

The chunk argument can now be a TypedArray or DataView instance.

The callback is invoked before 'finish' or on error.

The callback is invoked if 'finish' or 'error' is emitted.

This method now returns a reference to writable.

The chunk argument can now be a Uint8Array instance.

Added in: v0.9.4

Calling the writable.end() method signals that no more data will be written
to the Writable. The optional chunk and encoding arguments allow one
final additional chunk of data to be written immediately before closing the
stream.

Calling the stream.write() method after calling
stream.end() will raise an error.

This method now returns a reference to writable.

Added in: v0.11.15

The writable.setDefaultEncoding() method sets the default encoding for a
Writable stream.

The writable.uncork() method flushes all data buffered since
stream.cork() was called.

When using writable.cork() and writable.uncork() to manage the buffering
of writes to a stream, defer calls to writable.uncork() using
process.nextTick(). Doing so allows batching of all
writable.write() calls that occur within a given Node.js event loop phase.

If the writable.cork() method is called multiple times on a stream, the
same number of calls to writable.uncork() must be called to flush the buffered
data.

See also: writable.cork().

Is true if it is safe to call writable.write(), which means
the stream has not been destroyed, errored, or ended.

Marking the API stable.

Added in: v18.0.0, v16.17.0

Returns whether the stream was destroyed or errored before emitting 'finish'.

Is true after writable.end() has been called. This property
does not indicate whether the data has been flushed, for this use
writable.writableFinished instead.

Number of times writable.uncork() needs to be
called in order to fully uncork the stream.

Returns error if the stream has been destroyed with an error.

Is set to true immediately before the 'finish' event is emitted.

Return the value of highWaterMark passed when creating this Writable.

This property contains the number of bytes (or objects) in the queue
ready to be written. The value provides introspection data regarding
the status of the highWaterMark.

Is true if the stream's buffer has been full and stream will emit 'drain'.

Getter for the property objectMode of a given Writable stream.

No longer experimental.

Added in: v22.4.0, v20.16.0

Calls writable.destroy() with an AbortError and returns
a promise that fulfills when the stream is finished.

The chunk argument can now be a TypedArray or DataView instance.

The chunk argument can now be a Uint8Array instance.

Passing null as the chunk parameter will always be considered invalid now, even in object mode.

Added in: v0.9.4

The writable.write() method writes some data to the stream, and calls the
supplied callback once the data has been fully handled. If an error
occurs, the callback will be called with the error as its
first argument. The callback is called asynchronously and before 'error' is
emitted.

The return value is true if the internal buffer is less than the
highWaterMark configured when the stream was created after admitting chunk.
If false is returned, further attempts to write data to the stream should
stop until the 'drain' event is emitted.

While a stream is not draining, calls to write() will buffer chunk, and
return false. Once all currently buffered chunks are drained (accepted for
delivery by the operating system), the 'drain' event will be emitted.
Once write() returns false, do not write more chunks
until the 'drain' event is emitted. While calling write() on a stream that
is not draining is allowed, Node.js will buffer all written chunks until
maximum memory usage occurs, at which point it will abort unconditionally.
Even before it aborts, high memory usage will cause poor garbage collector
performance and high RSS (which is not typically released back to the system,
even after the memory is no longer required). Since TCP sockets may never
drain if the remote peer does not read the data, writing a socket that is
not draining may lead to a remotely exploitable vulnerability.

Writing data while the stream is not draining is particularly
problematic for a Transform, because the Transform streams are paused
by default until they are piped or a 'data' or 'readable' event handler
is added.

If the data to be written can be generated or fetched on demand, it is
recommended to encapsulate the logic into a Readable and use
stream.pipe(). However, if calling write() is preferred, it is
possible to respect backpressure and avoid memory issues using the
'drain' event:

A Writable stream in object mode will always ignore the encoding argument.

Readable streams are an abstraction for a source from which data is
consumed.

Examples of Readable streams include:

All Readable streams implement the interface defined by the
stream.Readable class.

Readable streams effectively operate in one of two modes: flowing and
paused. These modes are separate from object mode.
A Readable stream can be in object mode or not, regardless of whether
it is in flowing mode or paused mode.

In flowing mode, data is read from the underlying system automatically
and provided to an application as quickly as possible using events via the
EventEmitter interface.

In paused mode, the stream.read() method must be called
explicitly to read chunks of data from the stream.

All Readable streams begin in paused mode but can be switched to flowing
mode in one of the following ways:

The Readable can switch back to paused mode using one of the following:

The important concept to remember is that a Readable will not generate data
until a mechanism for either consuming or ignoring that data is provided. If
the consuming mechanism is disabled or taken away, the Readable will attempt
to stop generating the data.

For backward compatibility reasons, removing 'data' event handlers will
not automatically pause the stream. Also, if there are piped destinations,
then calling stream.pause() will not guarantee that the
stream will remain paused once those destinations drain and ask for more data.

If a Readable is switched into flowing mode and there are no consumers
available to handle the data, that data will be lost. This can occur, for
instance, when the readable.resume() method is called without a listener
attached to the 'data' event, or when a 'data' event handler is removed
from the stream.

Adding a 'readable' event handler automatically makes the stream
stop flowing, and the data has to be consumed via
readable.read(). If the 'readable' event handler is
removed, then the stream will start flowing again if there is a
'data' event handler.

The "two modes" of operation for a Readable stream are a simplified
abstraction for the more complicated internal state management that is happening
within the Readable stream implementation.

Specifically, at any given point in time, every Readable is in one of three
possible states:

When readable.readableFlowing is null, no mechanism for consuming the
stream's data is provided. Therefore, the stream will not generate data.
While in this state, attaching a listener for the 'data' event, calling the
readable.pipe() method, or calling the readable.resume() method will switch
readable.readableFlowing to true, causing the Readable to begin actively
emitting events as data is generated.

Calling readable.pause(), readable.unpipe(), or receiving backpressure
will cause the readable.readableFlowing to be set as false,
temporarily halting the flowing of events but not halting the generation of
data. While in this state, attaching a listener for the 'data' event
will not switch readable.readableFlowing to true.

While readable.readableFlowing is false, data may be accumulating
within the stream's internal buffer.

The Readable stream API evolved across multiple Node.js versions and provides
multiple methods of consuming stream data. In general, developers should choose
one of the methods of consuming data and should never use multiple methods
to consume data from a single stream. Specifically, using a combination
of on('data'), on('readable'), pipe(), or async iterators could
lead to unintuitive behavior.

Add emitClose option to specify if 'close' is emitted on destroy.

Added in: v0.9.4

The 'close' event is emitted when the stream and any of its underlying
resources (a file descriptor, for example) have been closed. The event indicates
that no more events will be emitted, and no further computation will occur.

A Readable stream will always emit the 'close' event if it is
created with the emitClose option.

The 'data' event is emitted whenever the stream is relinquishing ownership of
a chunk of data to a consumer. This may occur whenever the stream is switched
in flowing mode by calling readable.pipe(), readable.resume(), or by
attaching a listener callback to the 'data' event. The 'data' event will
also be emitted whenever the readable.read() method is called and a chunk of
data is available to be returned.

Attaching a 'data' event listener to a stream that has not been explicitly
paused will switch the stream into flowing mode. Data will then be passed as
soon as it is available.

The listener callback will be passed the chunk of data as a string if a default
encoding has been specified for the stream using the
readable.setEncoding() method; otherwise the data will be passed as a
Buffer.

The 'end' event is emitted when there is no more data to be consumed from
the stream.

The 'end' event will not be emitted unless the data is completely
consumed. This can be accomplished by switching the stream into flowing mode,
or by calling stream.read() repeatedly until all data has been
consumed.

The 'error' event may be emitted by a Readable implementation at any time.
Typically, this may occur if the underlying stream is unable to generate data
due to an underlying internal failure, or when a stream implementation attempts
to push an invalid chunk of data.

The listener callback will be passed a single Error object.

The 'pause' event is emitted when stream.pause() is called
and readableFlowing is not false.

The 'readable' is always emitted in the next tick after .push() is called.

Using 'readable' requires calling .read().

Added in: v0.9.4

The 'readable' event is emitted when there is data available to be read from
the stream, up to the configured high water mark (state.highWaterMark). Effectively,
it indicates that the stream has new information within the buffer. If data is available
within this buffer, stream.read() can be called to retrieve that data.
Additionally, the 'readable' event may also be emitted when the end of the stream has been
reached.

If the end of the stream has been reached, calling
stream.read() will return null and trigger the 'end'
event. This is also true if there never was any data to be read. For instance,
in the following example, foo.txt is an empty file:

The output of running this script is:

In some cases, attaching a listener for the 'readable' event will cause some
amount of data to be read into an internal buffer.

In general, the readable.pipe() and 'data' event mechanisms are easier to
understand than the 'readable' event. However, handling 'readable' might
result in increased throughput.

If both 'readable' and 'data' are used at the same time, 'readable'
takes precedence in controlling the flow, i.e. 'data' will be emitted
only when stream.read() is called. The
readableFlowing property would become false.
If there are 'data' listeners when 'readable' is removed, the stream
will start flowing, i.e. 'data'Â events will be emitted without calling
.resume().

The 'resume' event is emitted when stream.resume() is
called and readableFlowing is not true.

Work as a no-op on a stream that has already been destroyed.

Added in: v8.0.0

Destroy the stream. Optionally emit an 'error' event, and emit a 'close'
event (unless emitClose is set to false). After this call, the readable
stream will release any internal resources and subsequent calls to push()
will be ignored.

Once destroy() has been called any further calls will be a no-op and no
further errors except from _destroy() may be emitted as 'error'.

Implementors should not override this method, but instead implement
readable._destroy().

Is true after 'close' has been emitted.

Is true after readable.destroy() has been called.

The readable.isPaused() method returns the current operating state of the
Readable. This is used primarily by the mechanism that underlies the
readable.pipe() method. In most typical cases, there will be no reason to
use this method directly.

The readable.pause() method will cause a stream in flowing mode to stop
emitting 'data' events, switching out of flowing mode. Any data that
becomes available will remain in the internal buffer.

The readable.pause() method has no effect if there is a 'readable'
event listener.

The readable.pipe() method attaches a Writable stream to the readable,
causing it to switch automatically into flowing mode and push all of its data
to the attached Writable. The flow of data will be automatically managed
so that the destination Writable stream is not overwhelmed by a faster
Readable stream.

The following example pipes all of the data from the readable into a file
named file.txt:

It is possible to attach multiple Writable streams to a single Readable
stream.

The readable.pipe() method returns a reference to the destination stream
making it possible to set up chains of piped streams:

By default, stream.end() is called on the destination Writable
stream when the source Readable stream emits 'end', so that the
destination is no longer writable. To disable this default behavior, the end
option can be passed as false, causing the destination stream to remain open:

One important caveat is that if the Readable stream emits an error during
processing, the Writable destination is not closed automatically. If an
error occurs, it will be necessary to manually close each stream in order
to prevent memory leaks.

The process.stderr and process.stdout Writable streams are never
closed until the Node.js process exits, regardless of the specified options.

The readable.read() method reads data out of the internal buffer and
returns it. If no data is available to be read, null is returned. By default,
the data is returned as a Buffer object unless an encoding has been
specified using the readable.setEncoding() method or the stream is operating
in object mode.

The optional size argument specifies a specific number of bytes to read. If
size bytes are not available to be read, null will be returned unless
the stream has ended, in which case all of the data remaining in the internal
buffer will be returned.

If the size argument is not specified, all of the data contained in the
internal buffer will be returned.

The size argument must be less than or equal to 1 GiB.

The readable.read() method should only be called on Readable streams
operating in paused mode. In flowing mode, readable.read() is called
automatically until the internal buffer is fully drained.

Each call to readable.read() returns a chunk of data or null, signifying
that there's no more data to read at that moment. These chunks aren't automatically
concatenated. Because a single read() call does not return all the data, using
a while loop may be necessary to continuously read chunks until all data is retrieved.
When reading a large file, .read() might return null temporarily, indicating
that it has consumed all buffered content but there may be more data yet to be
buffered. In such cases, a new 'readable' event is emitted once there's more
data in the buffer, and the 'end' event signifies the end of data transmission.

Therefore to read a file's whole contents from a readable, it is necessary
to collect chunks across multiple 'readable' events:

A Readable stream in object mode will always return a single item from
a call to readable.read(size), regardless of the value of the
size argument.

If the readable.read() method returns a chunk of data, a 'data' event will
also be emitted.

Calling stream.read([size]) after the 'end' event has
been emitted will return null. No runtime error will be raised.

Is true if it is safe to call readable.read(), which means
the stream has not been destroyed or emitted 'error' or 'end'.

Marking the API stable.

Added in: v16.8.0

Returns whether the stream was destroyed or errored before emitting 'end'.

Marking the API stable.

Added in: v16.7.0, v14.18.0

Returns whether 'data' has been emitted.

Getter for the property encoding of a given Readable stream. The encoding
property can be set using the readable.setEncoding() method.

Becomes true when 'end' event is emitted.

Returns error if the stream has been destroyed with an error.

This property reflects the current state of a Readable stream as described
in the Three states section.

Returns the value of highWaterMark passed when creating this Readable.

This property contains the number of bytes (or objects) in the queue
ready to be read. The value provides introspection data regarding
the status of the highWaterMark.

Getter for the property objectMode of a given Readable stream.

The resume() has no effect if there is a 'readable' event listening.

Added in: v0.9.4

The readable.resume() method causes an explicitly paused Readable stream to
resume emitting 'data' events, switching the stream into flowing mode.

The readable.resume() method can be used to fully consume the data from a
stream without actually processing any of that data:

The readable.resume() method has no effect if there is a 'readable'
event listener.

The readable.setEncoding() method sets the character encoding for
data read from the Readable stream.

By default, no encoding is assigned and stream data will be returned as
Buffer objects. Setting an encoding causes the stream data
to be returned as strings of the specified encoding rather than as Buffer
objects. For instance, calling readable.setEncoding('utf8') will cause the
output data to be interpreted as UTF-8 data, and passed as strings. Calling
readable.setEncoding('hex') will cause the data to be encoded in hexadecimal
string format.

The Readable stream will properly handle multi-byte characters delivered
through the stream that would otherwise become improperly decoded if simply
pulled from the stream as Buffer objects.

The readable.unpipe() method detaches a Writable stream previously attached
using the stream.pipe() method.

If the destination is not specified, then all pipes are detached.

If the destination is specified, but no pipe is set up for it, then
the method does nothing.

The chunk argument can now be a TypedArray or DataView instance.

The chunk argument can now be a Uint8Array instance.

Added in: v0.9.11

Passing chunk as null signals the end of the stream (EOF) and behaves the
same as readable.push(null), after which no more data can be written. The EOF
signal is put at the end of the buffer and any buffered data will still be
flushed.

The readable.unshift() method pushes a chunk of data back into the internal
buffer. This is useful in certain situations where a stream is being consumed by
code that needs to "un-consume" some amount of data that it has optimistically
pulled out of the source, so that the data can be passed on to some other party.

The stream.unshift(chunk) method cannot be called after the 'end' event
has been emitted or a runtime error will be thrown.

Developers using stream.unshift() often should consider switching to
use of a Transform stream instead. See the API for stream implementers
section for more information.

Unlike stream.push(chunk), stream.unshift(chunk) will not
end the reading process by resetting the internal reading state of the stream.
This can cause unexpected results if readable.unshift() is called during a
read (i.e. from within a stream._read() implementation on a
custom stream). Following the call to readable.unshift() with an immediate
stream.push('') will reset the reading state appropriately,
however it is best to simply avoid calling readable.unshift() while in the
process of performing a read.

Prior to Node.js 0.10, streams did not implement the entire node:stream
module API as it is currently defined. (See Compatibility for more
information.)

When using an older Node.js library that emits 'data' events and has a
stream.pause() method that is advisory only, the
readable.wrap() method can be used to create a Readable stream that uses
the old stream as its data source.

It will rarely be necessary to use readable.wrap() but the method has been
provided as a convenience for interacting with older Node.js applications and
libraries.

Symbol.asyncIterator support is no longer experimental.

Added in: v10.0.0

If the loop terminates with a break, return, or a throw, the stream will
be destroyed. In other terms, iterating over a stream will consume the stream
fully. The stream will be read in chunks of size equal to the highWaterMark
option. In the code example above, data will be in a single chunk if the file
has less then 64 KiB of data because no highWaterMark option is provided to
fs.createReadStream().

No longer experimental.

Added in: v20.4.0, v18.18.0

Calls readable.destroy() with an AbortError and returns
a promise that fulfills when the stream is finished.

Marking the API stable.

Added in: v19.1.0, v18.13.0

readable.compose(s) is equivalent to stream.compose(readable, s).

This method also allows for an <AbortSignal> to be provided, which will destroy
the composed stream when aborted.

See stream.compose(...streams) for more information.

Marking the API stable.

Added in: v16.3.0

The iterator created by this method gives users the option to cancel the
destruction of the stream if the for await...of loop is exited by return,
break, or throw, or if the iterator should destroy the stream if the stream
emitted an error during iteration.

added highWaterMark in options.

Added in: v17.4.0, v16.14.0

This method allows mapping over the stream. The fn function will be called
for every chunk in the stream. If the fn function returns a promise - that
promise will be awaited before being passed to the result stream.

added highWaterMark in options.

Added in: v17.4.0, v16.14.0

This method allows filtering the stream. For each chunk in the stream the fn
function will be called and if it returns a truthy value, the chunk will be
passed to the result stream. If the fn function returns a promise - that
promise will be awaited.

This method allows iterating a stream. For each chunk in the stream the
fn function will be called. If the fn function returns a promise - that
promise will be awaited.

This method is different from for await...of loops in that it can optionally
process chunks concurrently. In addition, a forEach iteration can only be
stopped by having passed a signal option and aborting the related
AbortController while for await...of can be stopped with break or
return. In either case the stream will be destroyed.

This method is different from listening to the 'data' event in that it
uses the readable event in the underlying machinery and can limit the
number of concurrent fn calls.

This method allows easily obtaining the contents of a stream.

As this method reads the entire stream into memory, it negates the benefits of
streams. It's intended for interoperability and convenience, not as the primary
way to consume streams.

This method is similar to Array.prototype.some and calls fn on each chunk
in the stream until the awaited return value is true (or any truthy value).
Once an fn call on a chunk awaited return value is truthy, the stream is
destroyed and the promise is fulfilled with true. If none of the fn
calls on the chunks return a truthy value, the promise is fulfilled with
false.

This method is similar to Array.prototype.find and calls fn on each chunk
in the stream to find a chunk with a truthy value for fn. Once an fn call's
awaited return value is truthy, the stream is destroyed and the promise is
fulfilled with value for which fn returned a truthy value. If all of the
fn calls on the chunks return a falsy value, the promise is fulfilled with
undefined.

This method is similar to Array.prototype.every and calls fn on each chunk
in the stream to check if all awaited return values are truthy value for fn.
Once an fn call on a chunk awaited return value is falsy, the stream is
destroyed and the promise is fulfilled with false. If all of the fn calls
on the chunks return a truthy value, the promise is fulfilled with true.

This method returns a new stream by applying the given callback to each
chunk of the stream and then flattening the result.

It is possible to return a stream or another iterable or async iterable from
fn and the result streams will be merged (flattened) into the returned
stream.

This method returns a new stream with the first limit chunks dropped.

This method returns a new stream with the first limit chunks.

This method calls fn on each chunk of the stream in order, passing it the
result from the calculation on the previous element. It returns a promise for
the final value of the reduction.

If no initial value is supplied the first chunk of the stream is used as the
initial value. If the stream is empty, the promise is rejected with a
TypeError with the ERR_INVALID_ARGS code property.

The reducer function iterates the stream element-by-element which means that
there is no concurrency parameter or parallelism. To perform a reduce
concurrently, you can extract the async function to readable.map method.

Instances of Duplex now return true when checking instanceof stream.Writable.

Added in: v0.9.4

Duplex streams are streams that implement both the Readable and
Writable interfaces.

Examples of Duplex streams include:

If false then the stream will automatically end the writable side when the
readable side ends. Set initially by the allowHalfOpen constructor option,
which defaults to true.

This can be changed manually to change the half-open behavior of an existing
Duplex stream instance, but must be changed before the 'end' event is
emitted.

Transform streams are Duplex streams where the output is in some way
related to the input. Like all Duplex streams, Transform streams
implement both the Readable and Writable interfaces.

Examples of Transform streams include:

Work as a no-op on a stream that has already been destroyed.

Added in: v8.0.0

Destroy the stream, and optionally emit an 'error' event. After this call, the
transform stream would release any internal resources.
Implementors should not override this method, but instead implement
readable._destroy().
The default implementation of _destroy() for Transform also emit 'close'
unless emitClose is set in false.

Once destroy() has been called, any further calls will be a no-op and no
further errors except from _destroy() may be emitted as 'error'.

The utility function duplexPair returns an Array with two items,
each being a Duplex stream connected to the other side:

Whatever is written to one stream is made readable on the other. It provides
behavior analogous to a network connection, where the data written by the client
becomes readable by the server, and vice-versa.

The Duplex streams are symmetrical; one or the other may be used without any
difference in behavior.

Added support for ReadableStream and WritableStream.

The signal option was added.

The finished(stream, cb) will wait for the 'close' event before invoking the callback. The implementation tries to detect legacy streams and only apply this behavior to streams which are expected to emit 'close'.

Emitting 'close' before 'end' on a Readable stream will cause an ERR_STREAM_PREMATURE_CLOSE error.

Callback will be invoked on streams which have already finished before the call to finished(stream, cb).

Added in: v10.0.0

A function to get notified when a stream is no longer readable, writable
or has experienced an error or a premature close event.

Especially useful in error handling scenarios where a stream is destroyed
prematurely (like an aborted HTTP request), and will not emit 'end'
or 'finish'.

The finished API provides promise version.

stream.finished() leaves dangling event listeners (in particular
'error', 'end', 'finish' and 'close') after callback has been
invoked. The reason for this is so that unexpected 'error' events (due to
incorrect stream implementations) do not cause unexpected crashes.
If this is unwanted behavior then the returned cleanup function needs to be
invoked in the callback:

Added support for webstreams.

Passing an invalid callback to the callback argument now throws ERR_INVALID_ARG_TYPE instead of ERR_INVALID_CALLBACK.

The pipeline(..., cb) will wait for the 'close' event before invoking the callback. The implementation tries to detect legacy streams and only apply this behavior to streams which are expected to emit 'close'.

Add support for async generators.

Added in: v10.0.0

A module method to pipe between streams and generators forwarding errors and
properly cleaning up and provide a callback when the pipeline is complete.

The pipeline API provides a promise version.

stream.pipeline() will call stream.destroy(err) on all streams except:

stream.pipeline() leaves dangling event listeners on the streams
after the callback has been invoked. In the case of reuse of streams after
failure, this can cause event listener leaks and swallowed errors. If the last
stream is readable, dangling event listeners will be removed so that the last
stream can be consumed later.

stream.pipeline() closes all the streams when an error is raised.
The IncomingRequest usage with pipeline could lead to an unexpected behavior
once it would destroy the socket without sending the expected response.
See the example below:

Added support for stream class.

Added support for webstreams.

Added in: v16.9.0

Combines two or more streams into a Duplex stream that writes to the
first stream and reads from the last. Each provided stream is piped into
the next, using stream.pipeline. If any of the streams error then all
are destroyed, including the outer Duplex stream.

Because stream.compose returns a new stream that in turn can (and
should) be piped into other streams, it enables composition. In contrast,
when passing streams to stream.pipeline, typically the first stream is
a readable stream and the last a writable stream, forming a closed
circuit.

If passed a Function it must be a factory method taking a source
Iterable.

stream.compose can be used to convert async iterables, generators and
functions into streams.

For convenience, the readable.compose(stream) method is available on
<Readable> and <Duplex> streams as a wrapper for this function.

Marking the API stable.

Added in: v17.3.0, v16.14.0

Returns whether the stream has encountered an error.

Marking the API stable.

Added in: v17.4.0, v16.14.0

Returns whether the stream is readable.

Returns whether the stream is writable.

A utility method for creating readable streams out of iterators.

Calling Readable.from(string) or Readable.from(buffer) will not have
the strings or buffers be iterated to match the other streams semantics
for performance reasons.

If an Iterable object containing promises is passed as an argument,
it might result in unhandled rejection.

Marking the API stable.

Added in: v17.0.0

Marking the API stable.

Added in: v16.8.0

Returns whether the stream has been read from or cancelled.

Add 'type' option to specify 'bytes'.

Marking the API stable.

include strategy options on Readable.

Added in: v17.0.0

Marking the API stable.

Added in: v17.0.0

Marking the API stable.

Added in: v17.0.0

The src argument can now be a ReadableStream or WritableStream.

Added in: v16.8.0

A utility method for creating duplex streams.

If an Iterable object containing promises is passed as an argument,
it might result in unhandled rejection.

Marking the API stable.

Added in: v17.0.0

Add 'type' option to specify 'bytes'.

Marking the API stable.

Added in: v17.0.0

Added support for ReadableStream and WritableStream.

Added in: v15.4.0

Attaches an AbortSignal to a readable or writeable stream. This lets code
control stream destruction using an AbortController.

Calling abort on the AbortController corresponding to the passed
AbortSignal will behave the same way as calling .destroy(new AbortError())
on the stream, and controller.error(new AbortError()) for webstreams.

Or using an AbortSignal with a readable stream as an async iterable:

Or using an AbortSignal with a ReadableStream:

Returns the default highWaterMark used by streams.
Defaults to 65536 (64 KiB), or 16 for objectMode.

Sets the default highWaterMark used by streams.

The node:stream module API has been designed to make it possible to easily
implement streams using JavaScript's prototypal inheritance model.

First, a stream developer would declare a new JavaScript class that extends one
of the four basic stream classes (stream.Writable, stream.Readable,
stream.Duplex, or stream.Transform), making sure they call the appropriate
parent class constructor:

When extending streams, keep in mind what options the user
can and should provide before forwarding these to the base constructor. For
example, if the implementation makes assumptions in regard to the
autoDestroy and emitClose options, do not allow the
user to override these. Be explicit about what
options are forwarded instead of implicitly forwarding all options.

The new stream class must then implement one or more specific methods, depending
on the type of stream being created, as detailed in the chart below:

The implementation code for a stream should never call the "public" methods
of a stream that are intended for use by consumers (as described in the
API for stream consumers section). Doing so may lead to adverse side effects
in application code consuming the stream.

Avoid overriding public methods such as write(), end(), cork(),
uncork(), read() and destroy(), or emitting internal events such
as 'error', 'data', 'end', 'finish' and 'close' through .emit().
Doing so can break current and future stream invariants leading to behavior
and/or compatibility issues with other streams, stream utilities, and user
expectations.

For many simple cases, it is possible to create a stream without relying on
inheritance. This can be accomplished by directly creating instances of the
stream.Writable, stream.Readable, stream.Duplex, or stream.Transform
objects and passing appropriate methods as constructor options.

The stream.Writable class is extended to implement a Writable stream.

Custom Writable streams must call the new stream.Writable([options])
constructor and implement the writable._write() and/or writable._writev()
method.

bump default highWaterMark.

support passing in an AbortSignal.

Change autoDestroy option default to true.

Add autoDestroy option to automatically destroy() the stream when it emits 'finish' or errors.

Add emitClose option to specify if 'close' is emitted on destroy.

Or, when using pre-ES6 style constructors:

Or, using the simplified constructor approach:

Calling abort on the AbortController corresponding to the passed
AbortSignal will behave the same way as calling .destroy(new AbortError())
on the writeable stream.

The _construct() method MUST NOT be called directly. It may be implemented
by child classes, and if so, will be called by the internal Writable
class methods only.

This optional function will be called in a tick after the stream constructor
has returned, delaying any _write(), _final() and _destroy() calls until
callback is called. This is useful to initialize state or asynchronously
initialize resources before the stream can be used.

_write() is optional when providing _writev().

All Writable stream implementations must provide a
writable._write() and/or
writable._writev() method to send data to the underlying
resource.

Transform streams provide their own implementation of the
writable._write().

This function MUST NOT be called by application code directly. It should be
implemented by child classes, and called by the internal Writable class
methods only.

The callback function must be called synchronously inside of
writable._write() or asynchronously (i.e. different tick) to signal either
that the write completed successfully or failed with an error.
The first argument passed to the callback must be the Error object if the
call failed or null if the write succeeded.

All calls to writable.write() that occur between the time writable._write()
is called and the callback is called will cause the written data to be
buffered. When the callback is invoked, the stream might emit a 'drain'
event. If a stream implementation is capable of processing multiple chunks of
data at once, the writable._writev() method should be implemented.

If the decodeStrings property is explicitly set to false in the constructor
options, then chunk will remain the same object that is passed to .write(),
and may be a string rather than a Buffer. This is to support implementations
that have an optimized handling for certain string data encodings. In that case,
the encoding argument will indicate the character encoding of the string.
Otherwise, the encoding argument can be safely ignored.

The writable._write() method is prefixed with an underscore because it is
internal to the class that defines it, and should never be called directly by
user programs.

This function MUST NOT be called by application code directly. It should be
implemented by child classes, and called by the internal Writable class
methods only.

The writable._writev() method may be implemented in addition or alternatively
to writable._write() in stream implementations that are capable of processing
multiple chunks of data at once. If implemented and if there is buffered data
from previous writes, _writev() will be called instead of _write().

The writable._writev() method is prefixed with an underscore because it is
internal to the class that defines it, and should never be called directly by
user programs.

The _destroy() method is called by writable.destroy().
It can be overridden by child classes but it must not be called directly.

The _final() method must not be called directly. It may be implemented
by child classes, and if so, will be called by the internal Writable
class methods only.

This optional function will be called before the stream closes, delaying the
'finish' event until callback is called. This is useful to close resources
or write buffered data before a stream ends.

Errors occurring during the processing of the writable._write(),
writable._writev() and writable._final() methods must be propagated
by invoking the callback and passing the error as the first argument.
Throwing an Error from within these methods or manually emitting an 'error'
event results in undefined behavior.

If a Readable stream pipes into a Writable stream when Writable emits an
error, the Readable stream will be unpiped.

The following illustrates a rather simplistic (and somewhat pointless) custom
Writable stream implementation. While this specific Writable stream instance
is not of any real particular usefulness, the example illustrates each of the
required elements of a custom Writable stream instance:

Decoding buffers is a common task, for instance, when using transformers whose
input is a string. This is not a trivial process when using multi-byte
characters encoding, such as UTF-8. The following example shows how to decode
multi-byte strings using StringDecoder and Writable.

The stream.Readable class is extended to implement a Readable stream.

Custom Readable streams must call the new stream.Readable([options])
constructor and implement the readable._read() method.

bump default highWaterMark.

support passing in an AbortSignal.

Change autoDestroy option default to true.

Add autoDestroy option to automatically destroy() the stream when it emits 'end' or errors.

Or, when using pre-ES6 style constructors:

Or, using the simplified constructor approach:

Calling abort on the AbortController corresponding to the passed
AbortSignal will behave the same way as calling .destroy(new AbortError())
on the readable created.

The _construct() method MUST NOT be called directly. It may be implemented
by child classes, and if so, will be called by the internal Readable
class methods only.

This optional function will be scheduled in the next tick by the stream
constructor, delaying any _read() and _destroy() calls until callback is
called. This is useful to initialize state or asynchronously initialize
resources before the stream can be used.

This function MUST NOT be called by application code directly. It should be
implemented by child classes, and called by the internal Readable class
methods only.

All Readable stream implementations must provide an implementation of the
readable._read() method to fetch data from the underlying resource.

When readable._read() is called, if data is available from the resource,
the implementation should begin pushing that data into the read queue using the
this.push(dataChunk) method. _read() will be called again
after each call to this.push(dataChunk) once the stream is
ready to accept more data. _read() may continue reading from the resource and
pushing data until readable.push() returns false. Only when _read() is
called again after it has stopped should it resume pushing additional data into
the queue.

Once the readable._read() method has been called, it will not be called
again until more data is pushed through the readable.push()
method. Empty data such as empty buffers and strings will not cause
readable._read() to be called.

The size argument is advisory. For implementations where a "read" is a
single operation that returns data can use the size argument to determine how
much data to fetch. Other implementations may ignore this argument and simply
provide data whenever it becomes available. There is no need to "wait" until
size bytes are available before calling stream.push(chunk).

The readable._read() method is prefixed with an underscore because it is
internal to the class that defines it, and should never be called directly by
user programs.

The _destroy() method is called by readable.destroy().
It can be overridden by child classes but it must not be called directly.

The chunk argument can now be a TypedArray or DataView instance.

The chunk argument can now be a Uint8Array instance.

When chunk is a <Buffer>, <TypedArray>, <DataView> or <string>, the chunk
of data will be added to the internal queue for users of the stream to consume.
Passing chunk as null signals the end of the stream (EOF), after which no
more data can be written.

When the Readable is operating in paused mode, the data added with
readable.push() can be read out by calling the
readable.read() method when the 'readable' event is
emitted.

When the Readable is operating in flowing mode, the data added with
readable.push() will be delivered by emitting a 'data' event.

The readable.push() method is designed to be as flexible as possible. For
example, when wrapping a lower-level source that provides some form of
pause/resume mechanism, and a data callback, the low-level source can be wrapped
by the custom Readable instance:

The readable.push() method is used to push the content
into the internal buffer. It can be driven by the readable._read() method.

For streams not operating in object mode, if the chunk parameter of
readable.push() is undefined, it will be treated as empty string or
buffer. See readable.push('') for more information.

Errors occurring during processing of the readable._read() must be
propagated through the readable.destroy(err) method.
Throwing an Error from within readable._read() or manually emitting an
'error' event results in undefined behavior.

The following is a basic example of a Readable stream that emits the numerals
from 1 to 1,000,000 in ascending order, and then ends.

A Duplex stream is one that implements both Readable and
Writable, such as a TCP socket connection.

Because JavaScript does not have support for multiple inheritance, the
stream.Duplex class is extended to implement a Duplex stream (as opposed
to extending the stream.Readable and stream.Writable classes).

The stream.Duplex class prototypically inherits from stream.Readable and
parasitically from stream.Writable, but instanceof will work properly for
both base classes due to overriding Symbol.hasInstance on
stream.Writable.

Custom Duplex streams must call the new stream.Duplex([options])
constructor and implement both the readable._read() and
writable._write() methods.

The readableHighWaterMark and writableHighWaterMark options are supported now.

Or, when using pre-ES6 style constructors:

Or, using the simplified constructor approach:

When using pipeline:

The following illustrates a simple example of a Duplex stream that wraps a
hypothetical lower-level source object to which data can be written, and
from which data can be read, albeit using an API that is not compatible with
Node.js streams.
The following illustrates a simple example of a Duplex stream that buffers
incoming written data via the Writable interface that is read back out
via the Readable interface.

The most important aspect of a Duplex stream is that the Readable and
Writable sides operate independently of one another despite co-existing within
a single object instance.

For Duplex streams, objectMode can be set exclusively for either the
Readable or Writable side using the readableObjectMode and
writableObjectMode options respectively.

In the following example, for instance, a new Transform stream (which is a
type of Duplex stream) is created that has an object mode Writable side
that accepts JavaScript numbers that are converted to hexadecimal strings on
the Readable side.

A Transform stream is a Duplex stream where the output is computed
in some way from the input. Examples include zlib streams or crypto
streams that compress, encrypt, or decrypt data.

There is no requirement that the output be the same size as the input, the same
number of chunks, or arrive at the same time. For example, a Hash stream will
only ever have a single chunk of output which is provided when the input is
ended. A zlib stream will produce output that is either much smaller or much
larger than its input.

The stream.Transform class is extended to implement a Transform stream.

The stream.Transform class prototypically inherits from stream.Duplex and
implements its own versions of the writable._write() and
readable._read() methods. Custom Transform implementations must
implement the transform._transform() method and may
also implement the transform._flush() method.

Care must be taken when using Transform streams in that data written to the
stream can cause the Writable side of the stream to become paused if the
output on the Readable side is not consumed.

Or, when using pre-ES6 style constructors:

Or, using the simplified constructor approach:

The 'end' event is from the stream.Readable class. The 'end' event is
emitted after all data has been output, which occurs after the callback in
transform._flush() has been called. In the case of an error,
'end' should not be emitted.

The 'finish' event is from the stream.Writable class. The 'finish'
event is emitted after stream.end() is called and all chunks
have been processed by stream._transform(). In the case
of an error, 'finish' should not be emitted.

This function MUST NOT be called by application code directly. It should be
implemented by child classes, and called by the internal Readable class
methods only.

In some cases, a transform operation may need to emit an additional bit of
data at the end of the stream. For example, a zlib compression stream will
store an amount of internal state used to optimally compress the output. When
the stream ends, however, that additional data needs to be flushed so that the
compressed data will be complete.

Custom Transform implementations may implement the transform._flush()
method. This will be called when there is no more written data to be consumed,
but before the 'end' event is emitted signaling the end of the
Readable stream.

Within the transform._flush() implementation, the transform.push() method
may be called zero or more times, as appropriate. The callback function must
be called when the flush operation is complete.

The transform._flush() method is prefixed with an underscore because it is
internal to the class that defines it, and should never be called directly by
user programs.

This function MUST NOT be called by application code directly. It should be
implemented by child classes, and called by the internal Readable class
methods only.

All Transform stream implementations must provide a _transform()
method to accept input and produce output. The transform._transform()
implementation handles the bytes being written, computes an output, then passes
that output off to the readable portion using the transform.push() method.

The transform.push() method may be called zero or more times to generate
output from a single input chunk, depending on how much is to be output
as a result of the chunk.

It is possible that no output is generated from any given chunk of input data.

The callback function must be called only when the current chunk is completely
consumed. The first argument passed to the callback must be an Error object
if an error occurred while processing the input or null otherwise. If a second
argument is passed to the callback, it will be forwarded on to the
transform.push() method, but only if the first argument is falsy. In other
words, the following are equivalent:

The transform._transform() method is prefixed with an underscore because it
is internal to the class that defines it, and should never be called directly by
user programs.

transform._transform() is never called in parallel; streams implement a
queue mechanism, and to receive the next chunk, callback must be
called, either synchronously or asynchronously.

The stream.PassThrough class is a trivial implementation of a Transform
stream that simply passes the input bytes across to the output. Its purpose is
primarily for examples and testing, but there are some use cases where
stream.PassThrough is useful as a building block for novel sorts of streams.

With the support of async generators and iterators in JavaScript, async
generators are effectively a first-class language-level stream construct at
this point.

Some common interop cases of using Node.js streams with async generators
and async iterators are provided below.

Async iterators register a permanent error handler on the stream to prevent any
unhandled post-destroy errors.

A Node.js readable stream can be created from an asynchronous generator using
the Readable.from() utility method:

When writing to a writable stream from an async iterator, ensure correct
handling of backpressure and errors. stream.pipeline() abstracts away
the handling of backpressure and backpressure-related errors:

Prior to Node.js 0.10, the Readable stream interface was simpler, but also
less powerful and less useful.

In Node.js 0.10, the Readable class was added. For backward
compatibility with older Node.js programs, Readable streams switch into
"flowing mode" when a 'data' event handler is added, or when the
stream.resume() method is called. The effect is that, even
when not using the new stream.read() method and
'readable' event, it is no longer necessary to worry about losing
'data' chunks.

While most applications will continue to function normally, this introduces an
edge case in the following conditions:

For example, consider the following code:

Prior to Node.js 0.10, the incoming message data would be simply discarded.
However, in Node.js 0.10 and beyond, the socket remains paused forever.

The workaround in this situation is to call the
stream.resume() method to begin the flow of data:

In addition to new Readable streams switching into flowing mode,
pre-0.10 style streams can be wrapped in a Readable class using the
readable.wrap() method.

There are some cases where it is necessary to trigger a refresh of the
underlying readable stream mechanisms, without actually consuming any
data. In such cases, it is possible to call readable.read(0), which will
always return null.

If the internal read buffer is below the highWaterMark, and the
stream is not currently reading, then calling stream.read(0) will trigger
a low-level stream._read() call.

While most applications will almost never need to do this, there are
situations within Node.js where this is done, particularly in the
Readable stream class internals.

Use of readable.push('') is not recommended.

Pushing a zero-byte <string>, <Buffer>, <TypedArray> or <DataView> to a stream
that is not in object mode has an interesting side effect.
Because it is a call to
readable.push(), the call will end the reading process.
However, because the argument is an empty string, no data is added to the
readable buffer so there is nothing for a user to consume.

The use of readable.setEncoding() will change the behavior of how the
highWaterMark operates in non-object mode.

Typically, the size of the current buffer is measured against the
highWaterMark in bytes. However, after setEncoding() is called, the
comparison function will begin to measure the buffer's size in characters.

This is not a problem in common cases with latin1 or ascii. But it is
advised to be mindful about this behavior when working with strings that could
contain multi-byte characters.