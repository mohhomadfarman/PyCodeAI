Title: Crypto | Node.js v25.6.0 Documentation
Source: https://nodejs.org/api/crypto.html

Source Code: lib/crypto.js

The node:crypto module provides cryptographic functionality that includes a
set of wrappers for OpenSSL's hash, HMAC, cipher, decipher, sign, and verify
functions.

It is possible for Node.js to be built without including support for the
node:crypto module. In such cases, attempting to import from crypto or
calling require('node:crypto') will result in an error being thrown.

When using CommonJS, the error thrown can be caught using try/catch:

When using the lexical ESM import keyword, the error can only be
caught if a handler for process.on('uncaughtException') is registered
before any attempt to load the module is made (using, for instance,
a preload module).

When using ESM, if there is a chance that the code may be run on a build
of Node.js where crypto support is not enabled, consider using the
import() function instead of the lexical import keyword:

The following table lists the asymmetric key types recognized by the KeyObject API:

SPKAC is a Certificate Signing Request mechanism originally implemented by
Netscape and was specified formally as part of HTML5's keygen element.

<keygen> is deprecated since HTML 5.2 and new projects
should not use this element anymore.

The node:crypto module provides the Certificate class for working with SPKAC
data. The most common usage is handling output generated by the HTML5
<keygen> element. Node.js uses OpenSSL's SPKAC implementation internally.

The spkac argument can be an ArrayBuffer. Limited the size of the spkac argument to a maximum of 2**31 - 1 bytes.

Added in: v9.0.0

The spkac argument can be an ArrayBuffer. Limited the size of the spkac argument to a maximum of 2**31 - 1 bytes.

Added in: v9.0.0

The spkac argument can be an ArrayBuffer. Added encoding. Limited the size of the spkac argument to a maximum of 2**31 - 1 bytes.

Added in: v9.0.0

As a legacy interface, it is possible to create new instances of
the crypto.Certificate class as illustrated in the examples below.

Instances of the Certificate class can be created using the new keyword
or by calling crypto.Certificate() as a function:

Instances of the Cipheriv class are used to encrypt data. The class can be
used in one of two ways:

The crypto.createCipheriv() method is
used to create Cipheriv instances. Cipheriv objects are not to be created
directly using the new keyword.

Example: Using Cipheriv objects as streams:

Example: Using Cipheriv and piped streams:

Example: Using the cipher.update() and cipher.final() methods:

Once the cipher.final() method has been called, the Cipheriv object can no
longer be used to encrypt data. Attempts to call cipher.final() more than
once will result in an error being thrown.

The cipher.getAuthTag() method should only be called after encryption has
been completed using the cipher.final() method.

If the authTagLength option was set during the cipher instance's creation,
this function will return exactly authTagLength bytes.

When using an authenticated encryption mode (GCM, CCM, OCB, and
chacha20-poly1305 are
currently supported), the cipher.setAAD() method sets the value used for the
additional authenticated data (AAD) input parameter.

The plaintextLength option is optional for GCM and OCB. When using CCM,
the plaintextLength option must be specified and its value must match the
length of the plaintext in bytes. See CCM mode.

The cipher.setAAD() method must be called before cipher.update().

When using block encryption algorithms, the Cipheriv class will automatically
add padding to the input data to the appropriate block size. To disable the
default padding call cipher.setAutoPadding(false).

When autoPadding is false, the length of the entire input data must be a
multiple of the cipher's block size or cipher.final() will throw an error.
Disabling automatic padding is useful for non-standard padding, for instance
using 0x0 instead of PKCS padding.

The cipher.setAutoPadding() method must be called before
cipher.final().

The default inputEncoding changed from binary to utf8.

Added in: v0.1.94

Updates the cipher with data. If the inputEncoding argument is given,
the data
argument is a string using the specified encoding. If the inputEncoding
argument is not given, data must be a Buffer, TypedArray, or
DataView. If data is a Buffer, TypedArray, or DataView, then
inputEncoding is ignored.

The outputEncoding specifies the output format of the enciphered
data. If the outputEncoding
is specified, a string using the specified encoding is returned. If no
outputEncoding is provided, a Buffer is returned.

The cipher.update() method can be called multiple times with new data until
cipher.final() is called. Calling cipher.update() after
cipher.final() will result in an error being thrown.

Instances of the Decipheriv class are used to decrypt data. The class can be
used in one of two ways:

The crypto.createDecipheriv() method is
used to create Decipheriv instances. Decipheriv objects are not to be created
directly using the new keyword.

Example: Using Decipheriv objects as streams:

Example: Using Decipheriv and piped streams:

Example: Using the decipher.update() and decipher.final() methods:

Once the decipher.final() method has been called, the Decipheriv object can
no longer be used to decrypt data. Attempts to call decipher.final() more
than once will result in an error being thrown.

The buffer argument can be a string or ArrayBuffer and is limited to no more than 2 ** 31 - 1 bytes.

This method now returns a reference to decipher.

Added in: v1.0.0

When using an authenticated encryption mode (GCM, CCM, OCB, and
chacha20-poly1305 are
currently supported), the decipher.setAAD() method sets the value used for the
additional authenticated data (AAD) input parameter.

The options argument is optional for GCM. When using CCM, the
plaintextLength option must be specified and its value must match the length
of the ciphertext in bytes. See CCM mode.

The decipher.setAAD() method must be called before decipher.update().

When passing a string as the buffer, please consider
caveats when using strings as inputs to cryptographic APIs.

Using GCM tag lengths other than 128 bits without specifying the authTagLength option when creating decipher is deprecated.

The buffer argument can be a string or ArrayBuffer and is limited to no more than 2 ** 31 - 1 bytes.

This method now throws if the GCM tag length is invalid.

This method now returns a reference to decipher.

Added in: v1.0.0

When using an authenticated encryption mode (GCM, CCM, OCB, and
chacha20-poly1305 are
currently supported), the decipher.setAuthTag() method is used to pass in the
received authentication tag. If no tag is provided, or if the cipher text
has been tampered with, decipher.final() will throw, indicating that the
cipher text should be discarded due to failed authentication. If the tag length
is invalid according to NIST SP 800-38D or does not match the value of the
authTagLength option, decipher.setAuthTag() will throw an error.

The decipher.setAuthTag() method must be called before decipher.update()
for CCM mode or before decipher.final() for GCM and OCB modes and
chacha20-poly1305.
decipher.setAuthTag() can only be called once.

Because the node:crypto module was originally designed to closely mirror
OpenSSL's behavior, this function permits short GCM authentication tags unless
an explicit authentication tag length was passed to
crypto.createDecipheriv() when the decipher object was created. This
behavior is deprecated and subject to change (see DEP0182). 
In the meantime, applications should either set the authTagLength option when
calling createDecipheriv() or check the actual
authentication tag length before passing it to setAuthTag().

When passing a string as the authentication tag, please consider
caveats when using strings as inputs to cryptographic APIs.

When data has been encrypted without standard block padding, calling
decipher.setAutoPadding(false) will disable automatic padding to prevent
decipher.final() from checking for and removing padding.

Turning auto padding off will only work if the input data's length is a
multiple of the ciphers block size.

The decipher.setAutoPadding() method must be called before
decipher.final().

The default inputEncoding changed from binary to utf8.

Added in: v0.1.94

Updates the decipher with data. If the inputEncoding argument is given,
the data
argument is a string using the specified encoding. If the inputEncoding
argument is not given, data must be a Buffer. If data is a
Buffer then inputEncoding is ignored.

The outputEncoding specifies the output format of the enciphered
data. If the outputEncoding
is specified, a string using the specified encoding is returned. If no
outputEncoding is provided, a Buffer is returned.

The decipher.update() method can be called multiple times with new data until
decipher.final() is called. Calling decipher.update() after
decipher.final() will result in an error being thrown.

Even if the underlying cipher implements authentication, the authenticity and
integrity of the plaintext returned from this function may be uncertain at this
time. For authenticated encryption algorithms, authenticity is generally only
established when the application calls decipher.final().

The DiffieHellman class is a utility for creating Diffie-Hellman key
exchanges.

Instances of the DiffieHellman class can be created using the
crypto.createDiffieHellman() function.

Computes the shared secret using otherPublicKey as the other
party's public key and returns the computed shared secret. The supplied
key is interpreted using the specified inputEncoding, and secret is
encoded using specified outputEncoding.
If the inputEncoding is not
provided, otherPublicKey is expected to be a Buffer,
TypedArray, or DataView.

If outputEncoding is given a string is returned; otherwise, a
Buffer is returned.

Generates private and public Diffie-Hellman key values unless they have been
generated or computed already, and returns
the public key in the specified encoding. This key should be
transferred to the other party.
If encoding is provided a string is returned; otherwise a
Buffer is returned.

This function is a thin wrapper around DH_generate_key(). In particular,
once a private key has been generated or set, calling this function only updates
the public key but does not generate a new private key.

Returns the Diffie-Hellman generator in the specified encoding.
If encoding is provided a string is
returned; otherwise a Buffer is returned.

Returns the Diffie-Hellman prime in the specified encoding.
If encoding is provided a string is
returned; otherwise a Buffer is returned.

Returns the Diffie-Hellman private key in the specified encoding.
If encoding is provided a
string is returned; otherwise a Buffer is returned.

Returns the Diffie-Hellman public key in the specified encoding.
If encoding is provided a
string is returned; otherwise a Buffer is returned.

Sets the Diffie-Hellman private key. If the encoding argument is provided,
privateKey is expected
to be a string. If no encoding is provided, privateKey is expected
to be a Buffer, TypedArray, or DataView.

This function does not automatically compute the associated public key. Either
diffieHellman.setPublicKey() or diffieHellman.generateKeys() can be
used to manually provide the public key or to automatically derive it.

Sets the Diffie-Hellman public key. If the encoding argument is provided,
publicKey is expected
to be a string. If no encoding is provided, publicKey is expected
to be a Buffer, TypedArray, or DataView.

A bit field containing any warnings and/or errors resulting from a check
performed during initialization of the DiffieHellman object.

The following values are valid for this property (as defined in node:constants module):

The DiffieHellmanGroup class takes a well-known modp group as its argument.
It works the same as DiffieHellman, except that it does not allow changing
its keys after creation. In other words, it does not implement setPublicKey()
or setPrivateKey() methods.

The following groups are supported:

The following groups are still supported but deprecated (see Caveats):

These deprecated groups might be removed in future versions of Node.js.

The ECDH class is a utility for creating Elliptic Curve Diffie-Hellman (ECDH)
key exchanges.

Instances of the ECDH class can be created using the
crypto.createECDH() function.

Converts the EC Diffie-Hellman public key specified by key and curve to the
format specified by format. The format argument specifies point encoding
and can be 'compressed', 'uncompressed' or 'hybrid'. The supplied key is
interpreted using the specified inputEncoding, and the returned key is encoded
using the specified outputEncoding.

Use crypto.getCurves() to obtain a list of available curve names.
On recent OpenSSL releases, openssl ecparam -list_curves will also display
the name and description of each available elliptic curve.

If format is not specified the point will be returned in 'uncompressed'
format.

If the inputEncoding is not provided, key is expected to be a Buffer,
TypedArray, or DataView.

Example (uncompressing a key):

Changed error format to better support invalid public key error.

The default inputEncoding changed from binary to utf8.

Added in: v0.11.14

Computes the shared secret using otherPublicKey as the other
party's public key and returns the computed shared secret. The supplied
key is interpreted using specified inputEncoding, and the returned secret
is encoded using the specified outputEncoding.
If the inputEncoding is not
provided, otherPublicKey is expected to be a Buffer, TypedArray, or
DataView.

If outputEncoding is given a string will be returned; otherwise a
Buffer is returned.

ecdh.computeSecret will throw an
ERR_CRYPTO_ECDH_INVALID_PUBLIC_KEY error when otherPublicKey
lies outside of the elliptic curve. Since otherPublicKey is
usually supplied from a remote user over an insecure network,
be sure to handle this exception accordingly.

Generates private and public EC Diffie-Hellman key values, and returns
the public key in the specified format and encoding. This key should be
transferred to the other party.

The format argument specifies point encoding and can be 'compressed' or
'uncompressed'. If format is not specified, the point will be returned in
'uncompressed' format.

If encoding is provided a string is returned; otherwise a Buffer
is returned.

If encoding is specified, a string is returned; otherwise a Buffer is
returned.

The format argument specifies point encoding and can be 'compressed' or
'uncompressed'. If format is not specified the point will be returned in
'uncompressed' format.

If encoding is specified, a string is returned; otherwise a Buffer is
returned.

Sets the EC Diffie-Hellman private key.
If encoding is provided, privateKey is expected
to be a string; otherwise privateKey is expected to be a Buffer,
TypedArray, or DataView.

If privateKey is not valid for the curve specified when the ECDH object was
created, an error is thrown. Upon setting the private key, the associated
public point (key) is also generated and set in the ECDH object.

Sets the EC Diffie-Hellman public key.
If encoding is provided publicKey is expected to
be a string; otherwise a Buffer, TypedArray, or DataView is expected.

There is not normally a reason to call this method because ECDH
only requires a private key and the other party's public key to compute the
shared secret. Typically either ecdh.generateKeys() or
ecdh.setPrivateKey() will be called. The ecdh.setPrivateKey() method
attempts to generate the public point/key associated with the private key being
set.

Example (obtaining a shared secret):

The Hash class is a utility for creating hash digests of data. It can be
used in one of two ways:

The crypto.createHash() method is used to create Hash instances. Hash
objects are not to be created directly using the new keyword.

Example: Using Hash objects as streams:

Example: Using Hash and piped streams:

Example: Using the hash.update() and hash.digest() methods:

Creates a new Hash object that contains a deep copy of the internal state
of the current Hash object.

The optional options argument controls stream behavior. For XOF hash
functions such as 'shake256', the outputLength option can be used to
specify the desired output length in bytes.

An error is thrown when an attempt is made to copy the Hash object after
its hash.digest() method has been called.

Calculates the digest of all of the data passed to be hashed (using the
hash.update() method).
If encoding is provided a string will be returned; otherwise
a Buffer is returned.

The Hash object can not be used again after hash.digest() method has been
called. Multiple calls will cause an error to be thrown.

The default inputEncoding changed from binary to utf8.

Added in: v0.1.92

Updates the hash content with the given data, the encoding of which
is given in inputEncoding.
If encoding is not provided, and the data is a string, an
encoding of 'utf8' is enforced. If data is a Buffer, TypedArray, or
DataView, then inputEncoding is ignored.

This can be called many times with new data as it is streamed.

The Hmac class is a utility for creating cryptographic HMAC digests. It can
be used in one of two ways:

The crypto.createHmac() method is used to create Hmac instances. Hmac
objects are not to be created directly using the new keyword.

Example: Using Hmac objects as streams:

Example: Using Hmac and piped streams:

Example: Using the hmac.update() and hmac.digest() methods:

Calculates the HMAC digest of all of the data passed using hmac.update().
If encoding is
provided a string is returned; otherwise a Buffer is returned;

The Hmac object can not be used again after hmac.digest() has been
called. Multiple calls to hmac.digest() will result in an error being thrown.

The default inputEncoding changed from binary to utf8.

Added in: v0.1.94

Updates the Hmac content with the given data, the encoding of which
is given in inputEncoding.
If encoding is not provided, and the data is a string, an
encoding of 'utf8' is enforced. If data is a Buffer, TypedArray, or
DataView, then inputEncoding is ignored.

This can be called many times with new data as it is streamed.

Add support for ML-DSA keys.

Instances of this class can now be passed to worker threads using postMessage.

This class is now exported.

Added in: v11.6.0

Node.js uses a KeyObject class to represent a symmetric or asymmetric key,
and each kind of key exposes different functions. The
crypto.createSecretKey(), crypto.createPublicKey() and
crypto.createPrivateKey() methods are used to create KeyObject
instances. KeyObject objects are not to be created directly using the new
keyword.

Most applications should consider using the new KeyObject API instead of
passing keys as strings or Buffers due to improved security features.

KeyObject instances can be passed to other threads via postMessage().
The receiver obtains a cloned KeyObject, and the KeyObject does not need to
be listed in the transferList argument.

Example: Converting a CryptoKey instance to a KeyObject:

Expose RSASSA-PSS-params sequence parameters for RSA-PSS keys.

Added in: v15.7.0

This property exists only on asymmetric keys. Depending on the type of the key,
this object contains information about the key. None of the information obtained
through this property can be used to uniquely identify a key or to compromise
the security of the key.

For RSA-PSS keys, if the key material contains a RSASSA-PSS-params sequence,
the hashAlgorithm, mgf1HashAlgorithm, and saltLength properties will be
set.

Other key details might be exposed via this API using additional attributes.

Add support for SLH-DSA keys.

Add support for ML-KEM keys.

Add support for ML-DSA keys.

Added support for 'dh'.

Added support for 'rsa-pss'.

This property now returns undefined for KeyObject instances of unrecognized type instead of aborting.

Added support for 'x25519' and 'x448'.

Added support for 'ed25519' and 'ed448'.

Added in: v11.6.0

For asymmetric keys, this property represents the type of the key. See the
supported asymmetric key types.

This property is undefined for unrecognized KeyObject types and symmetric
keys.

Returns true or false depending on whether the keys have exactly the same
type, value, and parameters. This method is not
constant time.

Added support for 'jwk' format.

Added in: v11.6.0

For symmetric keys, the following encoding options can be used:

For public keys, the following encoding options can be used:

For private keys, the following encoding options can be used:

The result type depends on the selected encoding format, when PEM the
result is a string, when DER it will be a buffer containing the data
encoded as DER, when JWK it will be an object.

When JWK encoding format was selected, all other encoding options are
ignored.

PKCS#1, SEC1, and PKCS#8 type keys can be encrypted by using a combination of
the cipher and format options. The PKCS#8 type can be used with any
format to encrypt any key algorithm (RSA, EC, or DH) by specifying a
cipher. PKCS#1 and SEC1 can only be encrypted by specifying a cipher
when the PEM format is used. For maximum compatibility, use PKCS#8 for
encrypted private keys. Since PKCS#8 defines its own
encryption mechanism, PEM-level encryption is not supported when encrypting
a PKCS#8 key. See RFC 5208 for PKCS#8 encryption and RFC 1421 for
PKCS#1 and SEC1 encryption.

For secret keys, this property represents the size of the key in bytes. This
property is undefined for asymmetric keys.

Converts a KeyObject instance to a CryptoKey.

Depending on the type of this KeyObject, this property is either
'secret' for secret (symmetric) keys, 'public' for public (asymmetric) keys
or 'private' for private (asymmetric) keys.

The Sign class is a utility for generating signatures. It can be used in one
of two ways:

The crypto.createSign() method is used to create Sign instances. The
argument is the string name of the hash function to use. Sign objects are not
to be created directly using the new keyword.

Example: Using Sign and Verify objects as streams:

Example: Using the sign.update() and verify.update() methods:

The privateKey can also be an ArrayBuffer and CryptoKey.

This function now supports IEEE-P1363 DSA and ECDSA signatures.

This function now supports RSA-PSS keys.

This function now supports key objects.

Support for RSASSA-PSS and additional options was added.

Added in: v0.1.92

Calculates the signature on all the data passed through using either
sign.update() or sign.write().

If privateKey is not a KeyObject, this function behaves as if
privateKey had been passed to crypto.createPrivateKey(). If it is an
object, the following additional properties can be passed:

dsaEncoding <string> For DSA and ECDSA, this option specifies the
format of the generated signature. It can be one of the following:

padding <integer> Optional padding value for RSA, one of the following:

RSA_PKCS1_PSS_PADDING will use MGF1 with the same hash function
used to sign the message as specified in section 3.1 of RFC 4055, unless
an MGF1 hash function has been specified as part of the key in compliance with
section 3.3 of RFC 4055.

saltLength <integer> Salt length for when padding is
RSA_PKCS1_PSS_PADDING. The special value
crypto.constants.RSA_PSS_SALTLEN_DIGEST sets the salt length to the digest
size, crypto.constants.RSA_PSS_SALTLEN_MAX_SIGN (default) sets it to the
maximum permissible value.

If outputEncoding is provided a string is returned; otherwise a Buffer
is returned.

The Sign object can not be again used after sign.sign() method has been
called. Multiple calls to sign.sign() will result in an error being thrown.

The default inputEncoding changed from binary to utf8.

Added in: v0.1.92

Updates the Sign content with the given data, the encoding of which
is given in inputEncoding.
If encoding is not provided, and the data is a string, an
encoding of 'utf8' is enforced. If data is a Buffer, TypedArray, or
DataView, then inputEncoding is ignored.

This can be called many times with new data as it is streamed.

The Verify class is a utility for verifying signatures. It can be used in one
of two ways:

The crypto.createVerify() method is used to create Verify instances.
Verify objects are not to be created directly using the new keyword.

See Sign for examples.

The default inputEncoding changed from binary to utf8.

Added in: v0.1.92

Updates the Verify content with the given data, the encoding of which
is given in inputEncoding.
If inputEncoding is not provided, and the data is a string, an
encoding of 'utf8' is enforced. If data is a Buffer, TypedArray, or
DataView, then inputEncoding is ignored.

This can be called many times with new data as it is streamed.

The object can also be an ArrayBuffer and CryptoKey.

This function now supports IEEE-P1363 DSA and ECDSA signatures.

This function now supports RSA-PSS keys.

The key can now be a private key.

Support for RSASSA-PSS and additional options was added.

Added in: v0.1.92

Verifies the provided data using the given object and signature.

If object is not a KeyObject, this function behaves as if
object had been passed to crypto.createPublicKey(). If it is an
object, the following additional properties can be passed:

dsaEncoding <string> For DSA and ECDSA, this option specifies the
format of the signature. It can be one of the following:

padding <integer> Optional padding value for RSA, one of the following:

RSA_PKCS1_PSS_PADDING will use MGF1 with the same hash function
used to verify the message as specified in section 3.1 of RFC 4055, unless
an MGF1 hash function has been specified as part of the key in compliance with
section 3.3 of RFC 4055.

saltLength <integer> Salt length for when padding is
RSA_PKCS1_PSS_PADDING. The special value
crypto.constants.RSA_PSS_SALTLEN_DIGEST sets the salt length to the digest
size, crypto.constants.RSA_PSS_SALTLEN_AUTO (default) causes it to be
determined automatically.

The signature argument is the previously calculated signature for the data, in
the signatureEncoding.
If a signatureEncoding is specified, the signature is expected to be a
string; otherwise signature is expected to be a Buffer,
TypedArray, or DataView.

The verify object can not be used again after verify.verify() has been
called. Multiple calls to verify.verify() will result in an error being
thrown.

Because public keys can be derived from private keys, a private key may
be passed instead of a public key.

Encapsulates an X509 certificate and provides read-only access to
its information.

The subject option now defaults to 'default'.

The subject option can now be set to 'default'.

The wildcards, partialWildcards, multiLabelWildcards, and singleLabelSubdomains options have been removed since they had no effect.

Added in: v15.6.0

Checks whether the certificate matches the given email address.

If the 'subject' option is undefined or set to 'default', the certificate
subject is only considered if the subject alternative name extension either does
not exist or does not contain any email addresses.

If the 'subject' option is set to 'always' and if the subject alternative
name extension either does not exist or does not contain a matching email
address, the certificate subject is considered.

If the 'subject' option is set to 'never', the certificate subject is never
considered, even if the certificate contains no subject alternative names.

The subject option now defaults to 'default'.

The subject option can now be set to 'default'.

Added in: v15.6.0

Checks whether the certificate matches the given host name.

If the certificate matches the given host name, the matching subject name is
returned. The returned name might be an exact match (e.g., foo.example.com)
or it might contain wildcards (e.g., *.example.com). Because host name
comparisons are case-insensitive, the returned subject name might also differ
from the given name in capitalization.

If the 'subject' option is undefined or set to 'default', the certificate
subject is only considered if the subject alternative name extension either does
not exist or does not contain any DNS names. This behavior is consistent with
RFC 2818 ("HTTP Over TLS").

If the 'subject' option is set to 'always' and if the subject alternative
name extension either does not exist or does not contain a matching DNS name,
the certificate subject is considered.

If the 'subject' option is set to 'never', the certificate subject is never
considered, even if the certificate contains no subject alternative names.

The options argument has been removed since it had no effect.

Added in: v15.6.0

Checks whether the certificate matches the given IP address (IPv4 or IPv6).

Only RFC 5280 iPAddress subject alternative names are considered, and they
must match the given ip address exactly. Other subject alternative names as
well as the subject field of the certificate are ignored.

Checks whether this certificate was potentially issued by the given otherCert
by comparing the certificate metadata.

This is useful for pruning a list of possible issuer certificates which have been
selected using a more rudimentary filtering routine, i.e. just based on subject
and issuer names.

Finally, to verify that this certificate's signature was produced by a private key
corresponding to otherCert's public key use x509.verify(publicKey)
with otherCert's public key represented as a KeyObject
like so

Checks whether the public key for this certificate is consistent with
the given private key.

The SHA-1 fingerprint of this certificate.

Because SHA-1 is cryptographically broken and because the security of SHA-1 is
significantly worse than that of algorithms that are commonly used to sign
certificates, consider using x509.fingerprint256 instead.

The SHA-256 fingerprint of this certificate.

The SHA-512 fingerprint of this certificate.

Because computing the SHA-256 fingerprint is usually faster and because it is
only half the size of the SHA-512 fingerprint, x509.fingerprint256 may be
a better choice. While SHA-512 presumably provides a higher level of security in
general, the security of SHA-256 matches that of most algorithms that are
commonly used to sign certificates.

Parts of this string may be encoded as JSON string literals in response to CVE-2021-44532.

Added in: v15.6.0

A textual representation of the certificate's authority information access
extension.

This is a line feed separated list of access descriptions. Each line begins with
the access method and the kind of the access location, followed by a colon and
the value associated with the access location.

After the prefix denoting the access method and the kind of the access location,
the remainder of each line might be enclosed in quotes to indicate that the
value is a JSON string literal. For backward compatibility, Node.js only uses
JSON string literals within this property when necessary to avoid ambiguity.
Third-party code should be prepared to handle both possible entry formats.

The issuer identification included in this certificate.

The issuer certificate or undefined if the issuer certificate is not
available.

An array detailing the key extended usages for this certificate.

The public key <KeyObject> for this certificate.

A Buffer containing the DER encoding of this certificate.

The serial number of this certificate.

Serial numbers are assigned by certificate authorities and do not uniquely
identify certificates. Consider using x509.fingerprint256 as a unique
identifier instead.

The complete subject of this certificate.

Parts of this string may be encoded as JSON string literals in response to CVE-2021-44532.

Added in: v15.6.0

The subject alternative name specified for this certificate.

This is a comma-separated list of subject alternative names. Each entry begins
with a string identifying the kind of the subject alternative name followed by
a colon and the value associated with the entry.

Earlier versions of Node.js incorrectly assumed that it is safe to split this
property at the two-character sequence ', ' (see CVE-2021-44532). However,
both malicious and legitimate certificates can contain subject alternative names
that include this sequence when represented as a string.

After the prefix denoting the type of the entry, the remainder of each entry
might be enclosed in quotes to indicate that the value is a JSON string literal.
For backward compatibility, Node.js only uses JSON string literals within this
property when necessary to avoid ambiguity. Third-party code should be prepared
to handle both possible entry formats.

There is no standard JSON encoding for X509 certificates. The
toJSON() method returns a string containing the PEM encoded
certificate.

Returns information about this certificate using the legacy
certificate object encoding.

Returns the PEM-encoded certificate.

The date/time from which this certificate is valid.

The date/time from which this certificate is valid, encapsulated in a Date object.

The date/time until which this certificate is valid.

The date/time until which this certificate is valid, encapsulated in a Date object.

The algorithm used to sign the certificate or undefined if the signature algorithm is unknown by OpenSSL.

The OID of the algorithm used to sign the certificate.

Verifies that this certificate was signed by the given public key.
Does not perform any other validation checks on the certificate.

Provides an asynchronous Argon2 implementation. Argon2 is a password-based
key derivation function that is designed to be expensive computationally and
memory-wise in order to make brute-force attacks unrewarding.

The nonce should be as unique as possible. It is recommended that a nonce is
random and at least 16 bytes long. See NIST SP 800-132 for details.

When passing strings for message, nonce, secret or associatedData, please
consider caveats when using strings as inputs to cryptographic APIs.

The callback function is called with two arguments: err and derivedKey.
err is an exception object when key derivation fails, otherwise err is
null. derivedKey is passed to the callback as a Buffer.

An exception is thrown when any of the input arguments specify invalid values
or types.

Provides a synchronous Argon2 implementation. Argon2 is a password-based
key derivation function that is designed to be expensive computationally and
memory-wise in order to make brute-force attacks unrewarding.

The nonce should be as unique as possible. It is recommended that a nonce is
random and at least 16 bytes long. See NIST SP 800-132 for details.

When passing strings for message, nonce, secret or associatedData, please
consider caveats when using strings as inputs to cryptographic APIs.

An exception is thrown when key derivation fails, otherwise the derived key is
returned as a Buffer.

An exception is thrown when any of the input arguments specify invalid values
or types.

Passing an invalid callback to the callback argument now throws ERR_INVALID_ARG_TYPE instead of ERR_INVALID_CALLBACK.

Added in: v15.8.0

Checks the primality of the candidate.

Checks the primality of the candidate.

An object containing commonly used constants for crypto and security related
operations. The specific constants currently defined are described in
Crypto constants.

The authTagLength option is now optional when using the chacha20-poly1305 cipher and defaults to 16 bytes.

The password and iv arguments can be an ArrayBuffer and are each limited to a maximum of 2 ** 31 - 1 bytes.

The key argument can now be a KeyObject.

The cipher chacha20-poly1305 (the IETF variant of ChaCha20-Poly1305) is now supported.

Ciphers in OCB mode are now supported.

The authTagLength option can now be used to produce shorter authentication tags in GCM mode and defaults to 16 bytes.

The iv parameter may now be null for ciphers which do not need an initialization vector.

Added in: v0.1.94

Creates and returns a Cipheriv object, with the given algorithm, key and
initialization vector (iv).

The options argument controls stream behavior and is optional except when a
cipher in CCM or OCB mode (e.g. 'aes-128-ccm') is used. In that case, the
authTagLength option is required and specifies the length of the
authentication tag in bytes, see CCM mode. In GCM mode, the authTagLength
option is not required but can be used to set the length of the authentication
tag that will be returned by getAuthTag() and defaults to 16 bytes.
For chacha20-poly1305, the authTagLength option defaults to 16 bytes.

The algorithm is dependent on OpenSSL, examples are 'aes192', etc. On
recent OpenSSL releases, openssl list -cipher-algorithms will
display the available cipher algorithms.

The key is the raw key used by the algorithm and iv is an
initialization vector. Both arguments must be 'utf8' encoded strings,
Buffers, TypedArray, or DataViews. The key may optionally be
a KeyObject of type secret. If the cipher does not need
an initialization vector, iv may be null.

When passing strings for key or iv, please consider
caveats when using strings as inputs to cryptographic APIs.

Initialization vectors should be unpredictable and unique; ideally, they will be
cryptographically random. They do not have to be secret: IVs are typically just
added to ciphertext messages unencrypted. It may sound contradictory that
something has to be unpredictable and unique, but does not have to be secret;
remember that an attacker must not be able to predict ahead of time what a
given IV will be.

The authTagLength option is now optional when using the chacha20-poly1305 cipher and defaults to 16 bytes.

The key argument can now be a KeyObject.

The cipher chacha20-poly1305 (the IETF variant of ChaCha20-Poly1305) is now supported.

Ciphers in OCB mode are now supported.

The authTagLength option can now be used to restrict accepted GCM authentication tag lengths.

The iv parameter may now be null for ciphers which do not need an initialization vector.

Added in: v0.1.94

Creates and returns a Decipheriv object that uses the given algorithm, key
and initialization vector (iv).

The options argument controls stream behavior and is optional except when a
cipher in CCM or OCB mode (e.g. 'aes-128-ccm') is used. In that case, the
authTagLength option is required and specifies the length of the
authentication tag in bytes, see CCM mode.
For chacha20-poly1305, the authTagLength option defaults to 16
bytes and must be set to a different value if a different length is used.
For AES-GCM, the authTagLength option has no default value when decrypting,
and setAuthTag() will accept arbitrarily short authentication tags. This
behavior is deprecated and subject to change (see DEP0182). 
In the meantime, applications should either set the authTagLength option or
check the actual authentication tag length before passing it to setAuthTag().

The algorithm is dependent on OpenSSL, examples are 'aes192', etc. On
recent OpenSSL releases, openssl list -cipher-algorithms will
display the available cipher algorithms.

The key is the raw key used by the algorithm and iv is an
initialization vector. Both arguments must be 'utf8' encoded strings,
Buffers, TypedArray, or DataViews. The key may optionally be
a KeyObject of type secret. If the cipher does not need
an initialization vector, iv may be null.

When passing strings for key or iv, please consider
caveats when using strings as inputs to cryptographic APIs.

Initialization vectors should be unpredictable and unique; ideally, they will be
cryptographically random. They do not have to be secret: IVs are typically just
added to ciphertext messages unencrypted. It may sound contradictory that
something has to be unpredictable and unique, but does not have to be secret;
remember that an attacker must not be able to predict ahead of time what a given
IV will be.

The prime argument can be any TypedArray or DataView now.

The prime argument can be a Uint8Array now.

The default for the encoding parameters changed from binary to utf8.

Added in: v0.11.12

Creates a DiffieHellman key exchange object using the supplied prime and an
optional specific generator.

The generator argument can be a number, string, or Buffer. If
generator is not specified, the value 2 is used.

If primeEncoding is specified, prime is expected to be a string; otherwise
a Buffer, TypedArray, or DataView is expected.

If generatorEncoding is specified, generator is expected to be a string;
otherwise a number, Buffer, TypedArray, or DataView is expected.

Creates a DiffieHellman key exchange object and generates a prime of
primeLength bits using an optional specific numeric generator.
If generator is not specified, the value 2 is used.

An alias for crypto.getDiffieHellman()

Creates an Elliptic Curve Diffie-Hellman (ECDH) key exchange object using a
predefined curve specified by the curveName string. Use
crypto.getCurves() to obtain a list of available curve names. On recent
OpenSSL releases, openssl ecparam -list_curves will also display the name
and description of each available elliptic curve.

The outputLength option was added for XOF hash functions.

Added in: v0.1.92

Creates and returns a Hash object that can be used to generate hash digests
using the given algorithm. Optional options argument controls stream
behavior. For XOF hash functions such as 'shake256', the outputLength option
can be used to specify the desired output length in bytes.

The algorithm is dependent on the available algorithms supported by the
version of OpenSSL on the platform. Examples are 'sha256', 'sha512', etc.
On recent releases of OpenSSL, openssl list -digest-algorithms will
display the available digest algorithms.

Example: generating the sha256 sum of a file

The key can also be an ArrayBuffer or CryptoKey. The encoding option was added. The key cannot contain more than 2 ** 32 - 1 bytes.

The key argument can now be a KeyObject.

Added in: v0.1.94

Creates and returns an Hmac object that uses the given algorithm and key.
Optional options argument controls stream behavior.

The algorithm is dependent on the available algorithms supported by the
version of OpenSSL on the platform. Examples are 'sha256', 'sha512', etc.
On recent releases of OpenSSL, openssl list -digest-algorithms will
display the available digest algorithms.

The key is the HMAC key used to generate the cryptographic HMAC hash. If it is
a KeyObject, its type must be secret. If it is a string, please consider
caveats when using strings as inputs to cryptographic APIs. If it was
obtained from a cryptographically secure source of entropy, such as
crypto.randomBytes() or crypto.generateKey(), its length should not
exceed the block size of algorithm (e.g., 512 bits for SHA-256).

Example: generating the sha256 HMAC of a file

Add support for ML-DSA keys.

The key can also be a JWK object.

The key can also be an ArrayBuffer. The encoding option was added. The key cannot contain more than 2 ** 32 - 1 bytes.

Added in: v11.6.0

Creates and returns a new key object containing a private key. If key is a
string or Buffer, format is assumed to be 'pem'; otherwise, key
must be an object with the properties described above.

If the private key is encrypted, a passphrase must be specified. The length
of the passphrase is limited to 1024 bytes.

Add support for ML-DSA keys.

The key can also be a JWK object.

The key can also be an ArrayBuffer. The encoding option was added. The key cannot contain more than 2 ** 32 - 1 bytes.

The key argument can now be a KeyObject with type private.

The key argument can now be a private key.

Added in: v11.6.0

Creates and returns a new key object containing a public key. If key is a
string or Buffer, format is assumed to be 'pem'; if key is a KeyObject
with type 'private', the public key is derived from the given private key;
otherwise, key must be an object with the properties described above.

If the format is 'pem', the 'key' may also be an X.509 certificate.

Because public keys can be derived from private keys, a private key may be
passed instead of a public key. In that case, this function behaves as if
crypto.createPrivateKey() had been called, except that the type of the
returned KeyObject will be 'public' and that the private key cannot be
extracted from the returned KeyObject. Similarly, if a KeyObject with type
'private' is given, a new KeyObject with type 'public' will be returned
and it will be impossible to extract the private key from the returned object.

The key can now be zero-length.

The key can also be an ArrayBuffer or string. The encoding argument was added. The key cannot contain more than 2 ** 32 - 1 bytes.

Added in: v11.6.0

Creates and returns a new key object containing a secret key for symmetric
encryption or Hmac.

Creates and returns a Sign object that uses the given algorithm. Use
crypto.getHashes() to obtain the names of the available digest algorithms.
Optional options argument controls the stream.Writable behavior.

In some cases, a Sign instance can be created using the name of a signature
algorithm, such as 'RSA-SHA256', instead of a digest algorithm. This will use
the corresponding digest algorithm. This does not work for all signature
algorithms, such as 'ecdsa-with-SHA256', so it is best to always use digest
algorithm names.

Creates and returns a Verify object that uses the given algorithm.
Use crypto.getHashes() to obtain an array of names of the available
signing algorithms. Optional options argument controls the
stream.Writable behavior.

In some cases, a Verify instance can be created using the name of a signature
algorithm, such as 'RSA-SHA256', instead of a digest algorithm. This will use
the corresponding digest algorithm. This does not work for all signature
algorithms, such as 'ecdsa-with-SHA256', so it is best to always use digest
algorithm names.

Key decapsulation using a KEM algorithm with a private key.

Supported key types and their KEM algorithms are:

If key is not a KeyObject, this function behaves as if key had been
passed to crypto.createPrivateKey().

If the callback function is provided this function uses libuv's threadpool.

Optional callback argument added.

Added in: v13.9.0, v12.17.0

Computes the Diffie-Hellman shared secret based on a privateKey and a publicKey.
Both keys must have the same asymmetricKeyType and must support either the DH or
ECDH operation.

If the callback function is provided this function uses libuv's threadpool.

Key encapsulation using a KEM algorithm with a public key.

Supported key types and their KEM algorithms are:

If key is not a KeyObject, this function behaves as if key had been
passed to crypto.createPublicKey().

If the callback function is provided this function uses libuv's threadpool.

Property for checking and controlling whether a FIPS compliant crypto provider
is currently in use. Setting to true requires a FIPS build of Node.js.

This property is deprecated. Please use crypto.setFips() and
crypto.getFips() instead.

Passing an invalid callback to the callback argument now throws ERR_INVALID_ARG_TYPE instead of ERR_INVALID_CALLBACK.

Added in: v15.0.0

Asynchronously generates a new random secret key of the given length. The
type will determine which validations will be performed on the length.

The size of a generated HMAC key should not exceed the block size of the
underlying hash function. See crypto.createHmac() for more information.

Add support for SLH-DSA key pairs.

Add support for ML-KEM key pairs.

Add support for ML-DSA key pairs.

Passing an invalid callback to the callback argument now throws ERR_INVALID_ARG_TYPE instead of ERR_INVALID_CALLBACK.

Add ability to define RSASSA-PSS-params sequence parameters for RSA-PSS keys pairs.

Add support for Diffie-Hellman.

Add support for RSA-PSS key pairs.

Add ability to generate X25519 and X448 key pairs.

Add ability to generate Ed25519 and Ed448 key pairs.

The generateKeyPair and generateKeyPairSync functions now produce key objects if no encoding was specified.

Added in: v10.12.0

Generates a new asymmetric key pair of the given type. See the
supported asymmetric key types.

If a publicKeyEncoding or privateKeyEncoding was specified, this function
behaves as if keyObject.export() had been called on its result. Otherwise,
the respective part of the key is returned as a KeyObject.

It is recommended to encode public keys as 'spki' and private keys as
'pkcs8' with encryption for long-term storage:

On completion, callback will be called with err set to undefined and
publicKey / privateKey representing the generated key pair.

If this method is invoked as its util.promisify()ed version, it returns
a Promise for an Object with publicKey and privateKey properties.

Add support for SLH-DSA key pairs.

Add support for ML-KEM key pairs.

Add support for ML-DSA key pairs.

Add ability to define RSASSA-PSS-params sequence parameters for RSA-PSS keys pairs.

Add support for Diffie-Hellman.

Add support for RSA-PSS key pairs.

Add ability to generate X25519 and X448 key pairs.

Add ability to generate Ed25519 and Ed448 key pairs.

The generateKeyPair and generateKeyPairSync functions now produce key objects if no encoding was specified.

Added in: v10.12.0

Generates a new asymmetric key pair of the given type. See the
supported asymmetric key types.

If a publicKeyEncoding or privateKeyEncoding was specified, this function
behaves as if keyObject.export() had been called on its result. Otherwise,
the respective part of the key is returned as a KeyObject.

When encoding public keys, it is recommended to use 'spki'. When encoding
private keys, it is recommended to use 'pkcs8' with a strong passphrase,
and to keep the passphrase confidential.

The return value { publicKey, privateKey } represents the generated key pair.
When PEM encoding was selected, the respective key will be a string, otherwise
it will be a buffer containing the data encoded as DER.

Synchronously generates a new random secret key of the given length. The
type will determine which validations will be performed on the length.

The size of a generated HMAC key should not exceed the block size of the
underlying hash function. See crypto.createHmac() for more information.

Passing an invalid callback to the callback argument now throws ERR_INVALID_ARG_TYPE instead of ERR_INVALID_CALLBACK.

Added in: v15.8.0

Generates a pseudorandom prime of size bits.

If options.safe is true, the prime will be a safe prime -- that is,
(prime - 1) / 2 will also be a prime.

The options.add and options.rem parameters can be used to enforce additional
requirements, e.g., for Diffie-Hellman:

Both options.add and options.rem must be encoded as big-endian sequences
if given as an ArrayBuffer, SharedArrayBuffer, TypedArray, Buffer, or
DataView.

By default, the prime is encoded as a big-endian sequence of octets
in an <ArrayBuffer>. If the bigint option is true, then a <bigint>
is provided.

The size of the prime will have a direct impact on how long it takes to
generate the prime. The larger the size, the longer it will take. Because
we use OpenSSL's BN_generate_prime_ex function, which provides only
minimal control over our ability to interrupt the generation process,
it is not recommended to generate overly large primes, as doing so may make
the process unresponsive.

Generates a pseudorandom prime of size bits.

If options.safe is true, the prime will be a safe prime -- that is,
(prime - 1) / 2 will also be a prime.

The options.add and options.rem parameters can be used to enforce additional
requirements, e.g., for Diffie-Hellman:

Both options.add and options.rem must be encoded as big-endian sequences
if given as an ArrayBuffer, SharedArrayBuffer, TypedArray, Buffer, or
DataView.

By default, the prime is encoded as a big-endian sequence of octets
in an <ArrayBuffer>. If the bigint option is true, then a <bigint>
is provided.

The size of the prime will have a direct impact on how long it takes to
generate the prime. The larger the size, the longer it will take. Because
we use OpenSSL's BN_generate_prime_ex function, which provides only
minimal control over our ability to interrupt the generation process,
it is not recommended to generate overly large primes, as doing so may make
the process unresponsive.

Returns information about a given cipher.

Some ciphers accept variable length keys and initialization vectors. By default,
the crypto.getCipherInfo() method will return the default values for these
ciphers. To test if a given key length or iv length is acceptable for given
cipher, use the keyLength and ivLength options. If the given values are
unacceptable, undefined will be returned.

Creates a predefined DiffieHellmanGroup key exchange object. The
supported groups are listed in the documentation for DiffieHellmanGroup.

The returned object mimics the interface of objects created by
crypto.createDiffieHellman(), but will not allow changing
the keys (with diffieHellman.setPublicKey(), for example). The
advantage of using this method is that the parties do not have to
generate nor exchange a group modulus beforehand, saving both processor
and communication time.

Example (obtaining a shared secret):

A convenient alias for crypto.webcrypto.getRandomValues(). This
implementation is not compliant with the Web Crypto spec, to write
web-compatible code use crypto.webcrypto.getRandomValues() instead.

This API is no longer experimental.

The outputLength option was added for XOF hash functions.

Added in: v21.7.0, v20.12.0

A utility for creating one-shot hash digests of data. It can be faster than
the object-based crypto.createHash() when hashing a smaller amount of data
(<= 5MB) that's readily available. If the data can be big or if it is streamed,
it's still recommended to use crypto.createHash() instead.

The algorithm is dependent on the available algorithms supported by the
version of OpenSSL on the platform. Examples are 'sha256', 'sha512', etc.
On recent releases of OpenSSL, openssl list -digest-algorithms will
display the available digest algorithms.

If options is a string, then it specifies the outputEncoding.

Example:

Passing an invalid callback to the callback argument now throws ERR_INVALID_ARG_TYPE instead of ERR_INVALID_CALLBACK.

The input keying material can now be zero-length.

Added in: v15.0.0

HKDF is a simple key derivation function defined in RFC 5869. The given ikm,
salt and info are used with the digest to derive a key of keylen bytes.

The supplied callback function is called with two arguments: err and
derivedKey. If an errors occurs while deriving the key, err will be set;
otherwise err will be null. The successfully generated derivedKey will
be passed to the callback as an <ArrayBuffer>. An error will be thrown if any
of the input arguments specify invalid values or types.

The input keying material can now be zero-length.

Added in: v15.0.0

Provides a synchronous HKDF key derivation function as defined in RFC 5869. The
given ikm, salt and info are used with the digest to derive a key of
keylen bytes.

The successfully generated derivedKey will be returned as an <ArrayBuffer>.

An error will be thrown if any of the input arguments specify invalid values or
types, or if the derived key cannot be generated.

Passing an invalid callback to the callback argument now throws ERR_INVALID_ARG_TYPE instead of ERR_INVALID_CALLBACK.

The password and salt arguments can also be ArrayBuffer instances.

The iterations parameter is now restricted to positive values. Earlier releases treated other values as one.

The digest parameter is always required now.

Calling this function without passing the digest parameter is deprecated now and will emit a warning.

The default encoding for password if it is a string changed from binary to utf8.

Added in: v0.5.5

Provides an asynchronous Password-Based Key Derivation Function 2 (PBKDF2)
implementation. A selected HMAC digest algorithm specified by digest is
applied to derive a key of the requested byte length (keylen) from the
password, salt and iterations.

The supplied callback function is called with two arguments: err and
derivedKey. If an error occurs while deriving the key, err will be set;
otherwise err will be null. By default, the successfully generated
derivedKey will be passed to the callback as a Buffer. An error will be
thrown if any of the input arguments specify invalid values or types.

The iterations argument must be a number set as high as possible. The
higher the number of iterations, the more secure the derived key will be,
but will take a longer amount of time to complete.

The salt should be as unique as possible. It is recommended that a salt is
random and at least 16 bytes long. See NIST SP 800-132 for details.

When passing strings for password or salt, please consider
caveats when using strings as inputs to cryptographic APIs.

An array of supported digest functions can be retrieved using
crypto.getHashes().

This API uses libuv's threadpool, which can have surprising and
negative performance implications for some applications; see the
UV_THREADPOOL_SIZE documentation for more information.

The iterations parameter is now restricted to positive values. Earlier releases treated other values as one.

Calling this function without passing the digest parameter is deprecated now and will emit a warning.

The default encoding for password if it is a string changed from binary to utf8.

Added in: v0.9.3

Provides a synchronous Password-Based Key Derivation Function 2 (PBKDF2)
implementation. A selected HMAC digest algorithm specified by digest is
applied to derive a key of the requested byte length (keylen) from the
password, salt and iterations.

If an error occurs an Error will be thrown, otherwise the derived key will be
returned as a Buffer.

The iterations argument must be a number set as high as possible. The
higher the number of iterations, the more secure the derived key will be,
but will take a longer amount of time to complete.

The salt should be as unique as possible. It is recommended that a salt is
random and at least 16 bytes long. See NIST SP 800-132 for details.

When passing strings for password or salt, please consider
caveats when using strings as inputs to cryptographic APIs.

An array of supported digest functions can be retrieved using
crypto.getHashes().

The RSA_PKCS1_PADDING padding was disabled unless the OpenSSL build supports implicit rejection.

Added string, ArrayBuffer, and CryptoKey as allowable key types. The oaepLabel can be an ArrayBuffer. The buffer can be a string or ArrayBuffer. All types that accept buffers are limited to a maximum of 2 ** 31 - 1 bytes.

The oaepLabel option was added.

The oaepHash option was added.

This function now supports key objects.

Added in: v0.11.14

Decrypts buffer with privateKey. buffer was previously encrypted using
the corresponding public key, for example using crypto.publicEncrypt().

If privateKey is not a KeyObject, this function behaves as if
privateKey had been passed to crypto.createPrivateKey(). If it is an
object, the padding property can be passed. Otherwise, this function uses
RSA_PKCS1_OAEP_PADDING.

Using crypto.constants.RSA_PKCS1_PADDING in crypto.privateDecrypt()
requires OpenSSL to support implicit rejection (rsa_pkcs1_implicit_rejection).
If the version of OpenSSL used by Node.js does not support this feature,
attempting to use RSA_PKCS1_PADDING will fail.

Added string, ArrayBuffer, and CryptoKey as allowable key types. The passphrase can be an ArrayBuffer. The buffer can be a string or ArrayBuffer. All types that accept buffers are limited to a maximum of 2 ** 31 - 1 bytes.

This function now supports key objects.

Added in: v1.1.0

Encrypts buffer with privateKey. The returned data can be decrypted using
the corresponding public key, for example using crypto.publicDecrypt().

If privateKey is not a KeyObject, this function behaves as if
privateKey had been passed to crypto.createPrivateKey(). If it is an
object, the padding property can be passed. Otherwise, this function uses
RSA_PKCS1_PADDING.

Added string, ArrayBuffer, and CryptoKey as allowable key types. The passphrase can be an ArrayBuffer. The buffer can be a string or ArrayBuffer. All types that accept buffers are limited to a maximum of 2 ** 31 - 1 bytes.

This function now supports key objects.

Added in: v1.1.0

Decrypts buffer with key.buffer was previously encrypted using
the corresponding private key, for example using crypto.privateEncrypt().

If key is not a KeyObject, this function behaves as if
key had been passed to crypto.createPublicKey(). If it is an
object, the padding property can be passed. Otherwise, this function uses
RSA_PKCS1_PADDING.

Because RSA public keys can be derived from private keys, a private key may
be passed instead of a public key.

Added string, ArrayBuffer, and CryptoKey as allowable key types. The oaepLabel and passphrase can be ArrayBuffers. The buffer can be a string or ArrayBuffer. All types that accept buffers are limited to a maximum of 2 ** 31 - 1 bytes.

The oaepLabel option was added.

The oaepHash option was added.

This function now supports key objects.

Added in: v0.11.14

Encrypts the content of buffer with key and returns a new
Buffer with encrypted content. The returned data can be decrypted using
the corresponding private key, for example using crypto.privateDecrypt().

If key is not a KeyObject, this function behaves as if
key had been passed to crypto.createPublicKey(). If it is an
object, the padding property can be passed. Otherwise, this function uses
RSA_PKCS1_OAEP_PADDING.

Because RSA public keys can be derived from private keys, a private key may
be passed instead of a public key.

Passing an invalid callback to the callback argument now throws ERR_INVALID_ARG_TYPE instead of ERR_INVALID_CALLBACK.

Passing null as the callback argument now throws ERR_INVALID_CALLBACK.

Added in: v0.5.8

Generates cryptographically strong pseudorandom data. The size argument
is a number indicating the number of bytes to generate.

If a callback function is provided, the bytes are generated asynchronously
and the callback function is invoked with two arguments: err and buf.
If an error occurs, err will be an Error object; otherwise it is null. The
buf argument is a Buffer containing the generated bytes.

If the callback function is not provided, the random bytes are generated
synchronously and returned as a Buffer. An error will be thrown if
there is a problem generating the bytes.

The crypto.randomBytes() method will not complete until there is
sufficient entropy available.
This should normally never take longer than a few milliseconds. The only time
when generating the random bytes may conceivably block for a longer period of
time is right after boot, when the whole system is still low on entropy.

This API uses libuv's threadpool, which can have surprising and
negative performance implications for some applications; see the
UV_THREADPOOL_SIZE documentation for more information.

The asynchronous version of crypto.randomBytes() is carried out in a single
threadpool request. To minimize threadpool task length variation, partition
large randomBytes requests when doing so as part of fulfilling a client
request.

Passing an invalid callback to the callback argument now throws ERR_INVALID_ARG_TYPE instead of ERR_INVALID_CALLBACK.

The buffer argument may be any TypedArray or DataView.

Added in: v7.10.0, v6.13.0

This function is similar to crypto.randomBytes() but requires the first
argument to be a Buffer that will be filled. It also
requires that a callback is passed in.

If the callback function is not provided, an error will be thrown.

Any ArrayBuffer, TypedArray, or DataView instance may be passed as
buffer.

While this includes instances of Float32Array and Float64Array, this
function should not be used to generate random floating-point numbers. The
result may contain +Infinity, -Infinity, and NaN, and even if the array
contains finite numbers only, they are not drawn from a uniform random
distribution and have no meaningful lower or upper bounds.

This API uses libuv's threadpool, which can have surprising and
negative performance implications for some applications; see the
UV_THREADPOOL_SIZE documentation for more information.

The asynchronous version of crypto.randomFill() is carried out in a single
threadpool request. To minimize threadpool task length variation, partition
large randomFill requests when doing so as part of fulfilling a client
request.

The buffer argument may be any TypedArray or DataView.

Added in: v7.10.0, v6.13.0

Synchronous version of crypto.randomFill().

Any ArrayBuffer, TypedArray or DataView instance may be passed as
buffer.

Passing an invalid callback to the callback argument now throws ERR_INVALID_ARG_TYPE instead of ERR_INVALID_CALLBACK.

Added in: v14.10.0, v12.19.0

Return a random integer n such that min <= n < max.  This
implementation avoids modulo bias.

The range (max - min) must be less than 248. min and max must
be safe integers.

If the callback function is not provided, the random integer is
generated synchronously.

Generates a random RFC 4122 version 4 UUID. The UUID is generated using a
cryptographic pseudorandom number generator.

Passing an invalid callback to the callback argument now throws ERR_INVALID_ARG_TYPE instead of ERR_INVALID_CALLBACK.

The password and salt arguments can also be ArrayBuffer instances.

The maxmem value can now be any safe integer.

The cost, blockSize and parallelization option names have been added.

Added in: v10.5.0

Provides an asynchronous scrypt implementation. Scrypt is a password-based
key derivation function that is designed to be expensive computationally and
memory-wise in order to make brute-force attacks unrewarding.

The salt should be as unique as possible. It is recommended that a salt is
random and at least 16 bytes long. See NIST SP 800-132 for details.

When passing strings for password or salt, please consider
caveats when using strings as inputs to cryptographic APIs.

The callback function is called with two arguments: err and derivedKey.
err is an exception object when key derivation fails, otherwise err is
null. derivedKey is passed to the callback as a Buffer.

An exception is thrown when any of the input arguments specify invalid values
or types.

The maxmem value can now be any safe integer.

The cost, blockSize and parallelization option names have been added.

Added in: v10.5.0

Provides a synchronous scrypt implementation. Scrypt is a password-based
key derivation function that is designed to be expensive computationally and
memory-wise in order to make brute-force attacks unrewarding.

The salt should be as unique as possible. It is recommended that a salt is
random and at least 16 bytes long. See NIST SP 800-132 for details.

When passing strings for password or salt, please consider
caveats when using strings as inputs to cryptographic APIs.

An exception is thrown when key derivation fails, otherwise the derived key is
returned as a Buffer.

An exception is thrown when any of the input arguments specify invalid values
or types.

Custom engine support in OpenSSL 3 is deprecated.

Added in: v0.11.11

Load and set the engine for some or all OpenSSL functions (selected by flags).
Support for custom engines in OpenSSL is deprecated from OpenSSL 3.

engine could be either an id or a path to the engine's shared library.

The optional flags argument uses ENGINE_METHOD_ALL by default. The flags
is a bit field taking one of or a mix of the following flags (defined in
crypto.constants):

Enables the FIPS compliant crypto provider in a FIPS-enabled Node.js build.
Throws an error if FIPS mode is not available.

Add support for ML-DSA, Ed448, and SLH-DSA context parameter.

Add support for SLH-DSA signing.

Add support for ML-DSA signing.

Passing an invalid callback to the callback argument now throws ERR_INVALID_ARG_TYPE instead of ERR_INVALID_CALLBACK.

Optional callback argument added.

This function now supports IEEE-P1363 DSA and ECDSA signatures.

Added in: v12.0.0

Calculates and returns the signature for data using the given private key and
algorithm. If algorithm is null or undefined, then the algorithm is
dependent upon the key type.

algorithm is required to be null or undefined for Ed25519, Ed448, and
ML-DSA.

If key is not a KeyObject, this function behaves as if key had been
passed to crypto.createPrivateKey(). If it is an object, the following
additional properties can be passed:

dsaEncoding <string> For DSA and ECDSA, this option specifies the
format of the generated signature. It can be one of the following:

padding <integer> Optional padding value for RSA, one of the following:

RSA_PKCS1_PSS_PADDING will use MGF1 with the same hash function
used to sign the message as specified in section 3.1 of RFC 4055.

saltLength <integer> Salt length for when padding is
RSA_PKCS1_PSS_PADDING. The special value
crypto.constants.RSA_PSS_SALTLEN_DIGEST sets the salt length to the digest
size, crypto.constants.RSA_PSS_SALTLEN_MAX_SIGN (default) sets it to the
maximum permissible value.

context <ArrayBuffer> | <Buffer> | <TypedArray> | <DataView> For Ed448, ML-DSA, and SLH-DSA,
this option specifies the optional context to differentiate signatures generated
for different purposes with the same key.

If the callback function is provided this function uses libuv's threadpool.

A convenient alias for crypto.webcrypto.subtle.

The a and b arguments can also be ArrayBuffer.

Added in: v6.6.0

This function compares the underlying bytes that represent the given
ArrayBuffer, TypedArray, or DataView instances using a constant-time
algorithm.

This function does not leak timing information that
would allow an attacker to guess one of the values. This is suitable for
comparing HMAC digests or secret values like authentication cookies or
capability urls.

a and b must both be Buffers, TypedArrays, or DataViews, and they
must have the same byte length. An error is thrown if a and b have
different byte lengths.

If at least one of a and b is a TypedArray with more than one byte per
entry, such as Uint16Array, the result will be computed using the platform
byte order.

When both of the inputs are Float32Arrays or
Float64Arrays, this function might return unexpected results due to IEEE 754
encoding of floating-point numbers. In particular, neither x === y nor
Object.is(x, y) implies that the byte representations of two floating-point
numbers x and y are equal.

Use of crypto.timingSafeEqual does not guarantee that the surrounding code
is timing-safe. Care should be taken to ensure that the surrounding code does
not introduce timing vulnerabilities.

Add support for ML-DSA, Ed448, and SLH-DSA context parameter.

Add support for SLH-DSA signature verification.

Add support for ML-DSA signature verification.

Passing an invalid callback to the callback argument now throws ERR_INVALID_ARG_TYPE instead of ERR_INVALID_CALLBACK.

Optional callback argument added.

The data, key, and signature arguments can also be ArrayBuffer.

This function now supports IEEE-P1363 DSA and ECDSA signatures.

Added in: v12.0.0

Verifies the given signature for data using the given key and algorithm. If
algorithm is null or undefined, then the algorithm is dependent upon the
key type.

algorithm is required to be null or undefined for Ed25519, Ed448, and
ML-DSA.

If key is not a KeyObject, this function behaves as if key had been
passed to crypto.createPublicKey(). If it is an object, the following
additional properties can be passed:

dsaEncoding <string> For DSA and ECDSA, this option specifies the
format of the signature. It can be one of the following:

padding <integer> Optional padding value for RSA, one of the following:

RSA_PKCS1_PSS_PADDING will use MGF1 with the same hash function
used to sign the message as specified in section 3.1 of RFC 4055.

saltLength <integer> Salt length for when padding is
RSA_PKCS1_PSS_PADDING. The special value
crypto.constants.RSA_PSS_SALTLEN_DIGEST sets the salt length to the digest
size, crypto.constants.RSA_PSS_SALTLEN_MAX_SIGN (default) sets it to the
maximum permissible value.

context <ArrayBuffer> | <Buffer> | <TypedArray> | <DataView> For Ed448, ML-DSA, and SLH-DSA,
this option specifies the optional context to differentiate signatures generated
for different purposes with the same key.

The signature argument is the previously calculated signature for the data.

Because public keys can be derived from private keys, a private key or a public
key may be passed for key.

If the callback function is provided this function uses libuv's threadpool.

Type: <Crypto> An implementation of the Web Crypto API standard.

See the Web Crypto API documentation for details.

For historical reasons, many cryptographic APIs provided by Node.js accept
strings as inputs where the underlying cryptographic algorithm works on byte
sequences. These instances include plaintexts, ciphertexts, symmetric keys,
initialization vectors, passphrases, salts, authentication tags,
and additional authenticated data.

When passing strings to cryptographic APIs, consider the following factors.

Not all byte sequences are valid UTF-8 strings. Therefore, when a byte
sequence of length n is derived from a string, its entropy is generally
lower than the entropy of a random or pseudorandom n byte sequence.
For example, no UTF-8 string will result in the byte sequence c0 af. Secret
keys should almost exclusively be random or pseudorandom byte sequences.

Similarly, when converting random or pseudorandom byte sequences to UTF-8
strings, subsequences that do not represent valid code points may be replaced
by the Unicode replacement character (U+FFFD). The byte representation of
the resulting Unicode string may, therefore, not be equal to the byte sequence
that the string was created from.

The outputs of ciphers, hash functions, signature algorithms, and key
derivation functions are pseudorandom byte sequences and should not be
used as Unicode strings.

When strings are obtained from user input, some Unicode characters can be
represented in multiple equivalent ways that result in different byte
sequences. For example, when passing a user passphrase to a key derivation
function, such as PBKDF2 or scrypt, the result of the key derivation function
depends on whether the string uses composed or decomposed characters. Node.js
does not normalize character representations. Developers should consider using
String.prototype.normalize() on user inputs before passing them to
cryptographic APIs.

The Crypto module was added to Node.js before there was the concept of a
unified Stream API, and before there were Buffer objects for handling
binary data. As such, many crypto classes have methods not
typically found on other Node.js classes that implement the streams
API (e.g. update(), final(), or digest()). Also, many methods accepted
and returned 'latin1' encoded strings by default rather than Buffers. This
default was changed in Node.js 0.9.3 to use Buffer objects by default
instead.

The node:crypto module still supports some algorithms which are already
compromised and are not recommended for use. The API also allows
the use of ciphers and hashes with a small key size that are too weak for safe
use.

Users should take full responsibility for selecting the crypto
algorithm and key size according to their security requirements.

Based on the recommendations of NIST SP 800-131A:

See the reference for other recommendations and details.

Some algorithms that have known weaknesses and are of little relevance in
practice are only available through the legacy provider, which is not
enabled by default.

CCM is one of the supported AEAD algorithms. Applications which use this
mode must adhere to certain restrictions when using the cipher API:

When using OpenSSL 3, Node.js supports FIPS 140-2 when used with an appropriate
OpenSSL 3 provider, such as the FIPS provider from OpenSSL 3 which can be
installed by following the instructions in OpenSSL's FIPS README file.

For FIPS support in Node.js you will need:

Node.js will need to be configured with an OpenSSL configuration file that
points to the FIPS provider. An example configuration file looks like this:

where fipsmodule.cnf is the FIPS module configuration file generated from the
FIPS provider installation step:

Set the OPENSSL_CONF environment variable to point to
your configuration file and OPENSSL_MODULES to the location of the FIPS
provider dynamic library. e.g.

FIPS mode can then be enabled in Node.js either by:

Optionally FIPS mode can be enabled in Node.js via the OpenSSL configuration
file. e.g.

The following constants exported by crypto.constants apply to various uses of
the node:crypto, node:tls, and node:https modules and are generally
specific to OpenSSL.

See the list of SSL OP Flags for details.

Requires OpenSSL >= 3.5  2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24

Requires OpenSSL >= 3.0  2

Requires OpenSSL >= 3.2  2 3 4 5 6