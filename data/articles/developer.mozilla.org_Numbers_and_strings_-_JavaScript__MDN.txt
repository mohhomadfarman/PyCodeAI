Title: Numbers and strings - JavaScript | MDN
Source: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Text_formatting

This chapter introduces the two most fundamental data types in JavaScript: numbers and strings. We will introduce their underlying representations, and functions used to work with and perform calculations on them.

In JavaScript, numbers are implemented in double-precision 64-bit binary format IEEE 754 (i.e., a number between Â±2^â1022 and Â±2^+1023, or about Â±10^â308 to Â±10^+308, with a numeric precision of 53 bits). Integer values up to Â±2^53 â 1 can be represented exactly.

In addition to being able to represent floating-point numbers, the number type has three symbolic values: Infinity, -Infinity, and NaN (not-a-number).

See also JavaScript data types and structures for context with other primitive types in JavaScript.

You can use four types of number literals: decimal, binary, octal, and hexadecimal.

Decimal literals can start with a zero (0) followed by another decimal digit, but if all digits after the leading 0 are smaller than 8, the number is interpreted as an octal number. This is considered a legacy syntax, and number literals prefixed with 0, whether interpreted as octal or decimal, cause a syntax error in strict mode â so, use the 0o prefix instead.

Binary number syntax uses a leading zero followed by a lowercase or uppercase Latin letter "B" (0b or 0B). If the digits after the 0b are not 0 or 1, the following SyntaxError is thrown: "Missing binary digits after 0b".

The standard syntax for octal numbers is to prefix them with 0o. For example:

There's also a legacy syntax for octal numbers â by prefixing the octal number with a zero: 0644 === 420 and "\045" === "%". If the digits after the 0 are outside the range 0 through 7, the number will be interpreted as a decimal number.

Strict mode forbids this octal syntax.

Hexadecimal number syntax uses a leading zero followed by a lowercase or uppercase Latin letter "X" (0x or 0X). If the digits after 0x are outside the range (0123456789ABCDEF), the following SyntaxError is thrown: "Identifier starts immediately after numeric literal".

For all literal syntaxes shown above, an underscore (_) can be inserted between digits to improve readability.

See the lexical grammar reference for more details about number literals.

The built-in Number object has properties for numerical constants, such as maximum value, not-a-number, and infinity. You cannot change the values of these properties and you use them as follows:

You always refer to a property of the predefined Number object as shown above, and not as a property of a Number object you create yourself.

The following table summarizes the Number object's properties.

The Number prototype provides methods for retrieving information from Number objects in various formats. The following table summarizes the methods of Number.prototype.

The built-in Math object has properties and methods for mathematical constants and functions. For example, the Math object's PI property has the value of pi (3.141â¦), which you would use in an application as

Similarly, standard mathematical functions are methods of Math. These include trigonometric, logarithmic, exponential, and other functions. For example, if you want to use the trigonometric function sine, you would write

Note that all trigonometric methods of Math take arguments in radians.

The following table summarizes the Math object's methods.

pow(),
          exp(),
          expm1(),
          log(),
          log10(),
          log1p(),
          log2()

Unlike many other objects, you never create a Math object of your own. You always use the built-in Math object.

One shortcoming of number values is they only have 64 bits. In practice, due to using IEEE 754 encoding, they cannot represent any integer larger than Number.MAX_SAFE_INTEGER (which is 253 - 1) accurately. To solve the need of encoding binary data and to interoperate with other languages that offer wide integers like i64 (64-bit integers) and i128 (128-bit integers), JavaScript also offers another data type to represent arbitrarily large integers: BigInt.

A BigInt can be defined as an integer literal suffixed by n:

BigInts can also be constructed from number values or string values using the BigInt constructor.

Conceptually, a BigInt is just an arbitrarily long sequence of bits which encodes an integer. You can safely do any arithmetic operations without losing precision or over-/underflowing.

Compared to numbers, BigInt values yield higher precision when representing large integers; however, they cannot represent floating-point numbers. For example, division would round to zero:

Math functions cannot be used on BigInt values; they only work with numbers.

Choosing between BigInt and number depends on your use-case and your input's range. The precision of numbers should be able to accommodate most day-to-day tasks already, and BigInts are most suitable for handling binary data.

Read more about what you can do with BigInt values in the Expressions and Operators section, or the BigInt reference.

JavaScript's String type is used to represent textual data. It is a set of "elements" of 16-bit unsigned integer values (UTF-16 code units). Each element in the String occupies a position in the String. The first element is at index 0, the next at index 1, and so on. The length of a String is the number of elements in it. You can create strings using string literals or string objects.

You can declare strings in source code using either single or double quotes:

Within a string literal, most characters can be entered literally. The only exceptions are the backslash (\, which starts an escape sequence), the quote character being used to enclose the string, which terminates the string, and the newline character, which is a syntax error if not preceded by a backslash.

More advanced strings can be created using escape sequences:

The number after \x is interpreted as a hexadecimal number.

The Unicode escape sequences require at least four hexadecimal digits following \u.

With Unicode code point escapes, any character can be escaped using hexadecimal numbers so that it is possible to use Unicode code points up to 0x10FFFF. With the four-digit Unicode escapes it is often necessary to write the surrogate halves separately to achieve the same result.

See also String.fromCodePoint() or String.prototype.codePointAt().

You can call methods directly on a string value:

The following methods are available on String values:

When working with strings, there are two other objects that provide important functionality for string manipulation: RegExp and Intl. They are introduced in regular expressions and internationalization respectively.

Template literals are string literals allowing embedded expressions. You can use multi-line strings and string interpolation features with them.

Template literals are enclosed by backtick (grave accent) characters (`) instead of double or single quotes. Template literals can contain placeholders. These are indicated by the dollar sign and curly braces (${expression}).

Any new line characters inserted in the source are part of the template literal. Using normal strings, you would have to use the following syntax in order to get multi-line strings:

To get the same effect with multi-line strings, you can now write:

In order to embed expressions within normal strings, you would use the following syntax:

Now, with template literals, you are able to make use of the syntactic sugar making substitutions like this more readable:

For more information, read about Template literals in the JavaScript reference.

This page was last modified on Aug 26, 2025 by MDN contributors.