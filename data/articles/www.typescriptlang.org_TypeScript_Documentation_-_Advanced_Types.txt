Title: TypeScript: Documentation - Advanced Types
Source: https://www.typescriptlang.org/docs/handbook/advanced-types.html

This page lists some of the more advanced ways in which you can model types, it works in tandem with the Utility Types doc which includes types which are included in TypeScript and available globally.

Union types are useful for modeling situations when values can overlap in the types they can take on.
What happens when we need to know specifically whether we have a Fish?
A common idiom in JavaScript to differentiate between two possible values is to check for the presence of a member.
As we mentioned, you can only access members that are guaranteed to be in all the constituents of a union type.

To get the same code working via property accessors, we’ll need to use a type assertion:

This isn’t the sort of code you would want in your codebase however.

It would be much better if once we performed the check, we could know the type of pet within each branch.

It just so happens that TypeScript has something called a type guard.
A type guard is some expression that performs a runtime check that guarantees the type in some scope.

To define a type guard, we simply need to define a function whose return type is a type predicate:

pet is Fish is our type predicate in this example.
A predicate takes the form parameterName is Type, where parameterName must be the name of a parameter from the current function signature.

Any time isFish is called with some variable, TypeScript will narrow that variable to that specific type if the original type is compatible.

Notice that TypeScript not only knows that pet is a Fish in the if branch;
it also knows that in the else branch, you don’t have a Fish, so you must have a Bird.

You may use the type guard isFish to filter an array of Fish | Bird and obtain an array of Fish:

The in operator also acts as a narrowing expression for types.

For a n in x expression, where n is a string literal or string literal type and x is a union type, the “true” branch narrows to types which have an optional or required property n, and the “false” branch narrows to types which have an optional or missing property n.

Let’s go back and write the code for a version of padLeft which uses union types.
We could write it with type predicates as follows:

However, having to define a function to figure out if a type is a primitive is kind of a pain.
Luckily, you don’t need to abstract typeof x === "number" into its own function because TypeScript will recognize it as a type guard on its own.
That means we could just write these checks inline.

These typeof type guards are recognized in two different forms: typeof v === "typename" and typeof v !== "typename", where "typename" can be one of typeof operator’s return values ("undefined", "number", "string", "boolean", "bigint", "symbol", "object", or "function").
While TypeScript won’t stop you from comparing to other strings, the language won’t recognize those expressions as type guards.

If you’ve read about typeof type guards and are familiar with the instanceof operator in JavaScript, you probably have some idea of what this section is about.

instanceof type guards are a way of narrowing types using their constructor function.
For instance, let’s borrow our industrial strength string-padder example from earlier:

The right side of the instanceof needs to be a constructor function, and TypeScript will narrow down to:

in that order.

TypeScript has two special types, null and undefined, that have the values null and undefined respectively.
We mentioned these briefly in the Basic Types section.

By default, the type checker considers null and undefined assignable to anything.
Effectively, null and undefined are valid values of every type.
That means it’s not possible to stop them from being assigned to any type, even when you would like to prevent it.
The inventor of null, Tony Hoare, calls this his “billion dollar mistake”.

The strictNullChecks flag fixes this: when you declare a variable, it doesn’t automatically include null or undefined.
You can include them explicitly using a union type:

Note that TypeScript treats null and undefined differently in order to match JavaScript semantics.
string | null is a different type than string | undefined and string | undefined | null.

From TypeScript 3.7 and onwards, you can use optional chaining to simplify working with nullable types.

With strictNullChecks, an optional parameter automatically adds | undefined:

The same is true for optional properties:

Since nullable types are implemented with a union, you need to use a type guard to get rid of the null.
Fortunately, this is the same code you’d write in JavaScript:

The null elimination is pretty obvious here, but you can use terser operators too:

In cases where the compiler can’t eliminate null or undefined, you can use the type assertion operator to manually remove them.
The syntax is postfix !: identifier! removes null and undefined from the type of identifier:

Type aliases create a new name for a type.
Type aliases are sometimes similar to interfaces, but can name primitives, unions, tuples, and any other types that you’d otherwise have to write by hand.

Aliasing doesn’t actually create a new type - it creates a new name to refer to that type.
Aliasing a primitive is not terribly useful, though it can be used as a form of documentation.

Just like interfaces, type aliases can also be generic - we can just add type parameters and use them on the right side of the alias declaration:

We can also have a type alias refer to itself in a property:

Together with intersection types, we can make some pretty mind-bending types:

As we mentioned, type aliases can act sort of like interfaces; however, there are some subtle differences.

Almost all features of an interface are available in type, the key distinction is that a type cannot be re-opened to add new properties vs an interface which is always extendable.

Extending an interface

Extending a type via intersections

Adding new fields to an existing interface

A type cannot be changed after being created

Because an interface more closely maps how JavaScript objects work by being open to extension, we recommend using an interface over a type alias when possible.

On the other hand, if you can’t express some shape with an interface and you need to use a union or tuple type, type aliases are usually the way to go.

As mentioned in our section on enums, enum members have types when every member is literal-initialized.

Much of the time when we talk about “singleton types”, we’re referring to both enum member types as well as numeric/string literal types, though many users will use “singleton types” and “literal types” interchangeably.

A polymorphic this type represents a type that is the subtype of the containing class or interface.
This is called F-bounded polymorphism, a lot of people know it as the fluent API pattern.
This makes hierarchical fluent interfaces much easier to express, for example.
Take a simple calculator that returns this after each operation:

Since the class uses this types, you can extend it and the new class can use the old methods with no changes.

Without this types, ScientificCalculator would not have been able to extend BasicCalculator and keep the fluent interface.
multiply would have returned BasicCalculator, which doesn’t have the sin method.
However, with this types, multiply returns this, which is ScientificCalculator here.

With index types, you can get the compiler to check code that uses dynamic property names.
For example, a common JavaScript pattern is to pick a subset of properties from an object:

Here’s how you would write and use this function in TypeScript, using the index type query and indexed access operators:

The compiler checks that manufacturer and model are actually properties on Car.
The example introduces a couple of new type operators.
First is keyof T, the index type query operator.
For any type T, keyof T is the union of known, public property names of T.
For example:

keyof Car is completely interchangeable with "manufacturer" | "model" | "year".
The difference is that if you add another property to Car, say ownersAddress: string, then keyof Car will automatically update to be "manufacturer" | "model" | "year" | "ownersAddress".
And you can use keyof in generic contexts like pluck, where you can’t possibly know the property names ahead of time.
That means the compiler will check that you pass the right set of property names to pluck:

The second operator is T[K], the indexed access operator.
Here, the type syntax reflects the expression syntax.
That means that taxi["manufacturer"] has the type Car["manufacturer"] — which in our example is just string.
However, just like index type queries, you can use T[K] in a generic context, which is where its real power comes to life.
You just have to make sure that the type variable K extends keyof T.
Here’s another example with a function named getProperty.

In getProperty, o: T and propertyName: K, so that means o[propertyName]: T[K].
Once you return the T[K] result, the compiler will instantiate the actual type of the key, so the return type of getProperty will vary according to which property you request.

keyof and T[K] interact with index signatures. An index signature parameter type must be ‘string’ or ‘number’.
If you have a type with a string index signature, keyof T will be string | number
(and not just string, since in JavaScript you can access an object property either
by using strings (object["42"]) or numbers (object[42])).
And T[string] is just the type of the index signature:

If you have a type with a number index signature, keyof T will just be number.

A common task is to take an existing type and make each of its properties optional:

Or we might want a readonly version:

This happens often enough in JavaScript that TypeScript provides a way to create new types based on old types — mapped types.
In a mapped type, the new type transforms each property in the old type in the same way.
For example, you can make all properties optional or of a type readonly.
Here are a couple of examples:

And to use it:

Note that this syntax describes a type rather than a member.
If you want to add members, you can use an intersection type:

Let’s take a look at the simplest mapped type and its parts:

The syntax resembles the syntax for index signatures with a for .. in inside.
There are three parts:

In this simple example, Keys is a hard-coded list of property names and the property type is always boolean, so this mapped type is equivalent to writing:

Real applications, however, look like Readonly or Partial above.
They’re based on some existing type, and they transform the properties in some way.
That’s where keyof and indexed access types come in:

But it’s more useful to have a general version.

In these examples, the properties list is keyof T and the resulting type is some variant of T[P].
This is a good template for any general use of mapped types.
That’s because this kind of transformation is homomorphic, which means that the mapping applies only to properties of T and no others.
The compiler knows that it can copy all the existing property modifiers before adding any new ones.
For example, if Person.name was readonly, Partial<Person>.name would be readonly and optional.

Here’s one more example, in which T[P] is wrapped in a Proxy<T> class:

Note that Readonly<T> and Partial<T> are so useful, they are included in TypeScript’s standard library along with Pick and Record:

Readonly, Partial and Pick are homomorphic whereas Record is not.
One clue that Record is not homomorphic is that it doesn’t take an input type to copy properties from:

Non-homomorphic types are essentially creating new properties, so they can’t copy property modifiers from anywhere.

Note that keyof any represents the type of any value that can be used as an index to an object. In otherwords, keyof any is currently equal to string | number | symbol.

Now that you know how to wrap the properties of a type, the next thing you’ll want to do is unwrap them.
Fortunately, that’s pretty easy:

Note that this unwrapping inference only works on homomorphic mapped types.
If the mapped type is not homomorphic you’ll have to give an explicit type parameter to your unwrapping function.

A conditional type selects one of two possible types based on a condition expressed as a type relationship test:

The type above means when T is assignable to U the type is X, otherwise the type is Y.

A conditional type T extends U ? X : Y is either resolved to X or Y, or deferred because the condition depends on one or more type variables.
When T or U contains type variables, whether to resolve to X or Y, or to defer, is determined by whether or not the type system has enough information to conclude that T is always assignable to U.

As an example of some types that are immediately resolved, we can take a look at the following example:

Another example would be the TypeName type alias, which uses nested conditional types:

But as an example of a place where conditional types are deferred - where they stick around instead of picking a branch - would be in the following:

In the above, the variable a has a conditional type that hasn’t yet chosen a branch.
When another piece of code ends up calling foo, it will substitute in U with some other type, and TypeScript will re-evaluate the conditional type, deciding whether it can actually pick a branch.

In the meantime, we can assign a conditional type to any other target type as long as each branch of the conditional is assignable to that target.
So in our example above we were able to assign U extends Foo ? string : number to string | number since no matter what the conditional evaluates to, it’s known to be either string or number.

Conditional types in which the checked type is a naked type parameter are called distributive conditional types.
Distributive conditional types are automatically distributed over union types during instantiation.
For example, an instantiation of T extends U ? X : Y with the type argument A | B | C for T is resolved as (A extends U ? X : Y) | (B extends U ? X : Y) | (C extends U ? X : Y).

In instantiations of a distributive conditional type T extends U ? X : Y, references to T within the conditional type are resolved to individual constituents of the union type (i.e. T refers to the individual constituents after the conditional type is distributed over the union type).
Furthermore, references to T within X have an additional type parameter constraint U (i.e. T is considered assignable to U within X).

Notice that T has the additional constraint any[] within the true branch of Boxed<T> and it is therefore possible to refer to the element type of the array as T[number]. Also, notice how the conditional type is distributed over the union type in the last example.

The distributive property of conditional types can conveniently be used to filter union types:

Conditional types are particularly useful when combined with mapped types:

Note, conditional types are not permitted to reference themselves recursively. For example the following is an error.

Within the extends clause of a conditional type, it is now possible to have infer declarations that introduce a type variable to be inferred.
Such inferred type variables may be referenced in the true branch of the conditional type.
It is possible to have multiple infer locations for the same type variable.

For example, the following extracts the return type of a function type:

Conditional types can be nested to form a sequence of pattern matches that are evaluated in order:

The following example demonstrates how multiple candidates for the same type variable in co-variant positions causes a union type to be inferred:

Likewise, multiple candidates for the same type variable in contra-variant positions causes an intersection type to be inferred:

When inferring from a type with multiple call signatures (such as the type of an overloaded function), inferences are made from the last signature (which, presumably, is the most permissive catch-all case).
It is not possible to perform overload resolution based on a list of argument types.

It is not possible to use infer declarations in constraint clauses for regular type parameters:

However, much the same effect can be obtained by erasing the type variables in the constraint and instead specifying a conditional type:

TypeScript adds several predefined conditional types, you can find the full list and examples in Utility Types.