Title: Property flags and descriptors
Source: https://javascript.info/property-descriptors

As we know, objects can store properties.

Until now, a property was a simple “key-value” pair to us. But an object property is actually a more flexible and powerful thing.

In this chapter we’ll study additional configuration options, and in the next we’ll see how to invisibly turn them into getter/setter functions.

Object properties, besides a value, have three special attributes (so-called “flags”):

We didn’t see them yet, because generally they do not show up. When we create a property “the usual way”, all of them are true. But we also can change them anytime.

First, let’s see how to get those flags.

The method Object.getOwnPropertyDescriptor allows to query the full information about a property.

The syntax is:

The returned value is a so-called “property descriptor” object: it contains the value and all the flags.

For instance:

To change the flags, we can use Object.defineProperty.

The syntax is:

If the property exists, defineProperty updates its flags. Otherwise, it creates the property with the given value and flags; in that case, if a flag is not supplied, it is assumed false.

For instance, here a property name is created with all falsy flags:

Compare it with “normally created” user.name above: now all flags are falsy. If that’s not what we want then we’d better set them to true in descriptor.

Now let’s see effects of the flags by example.

Let’s make user.name non-writable (can’t be reassigned) by changing writable flag:

Now no one can change the name of our user, unless they apply their own defineProperty to override ours.

In non-strict mode, no errors occur when writing to non-writable properties and such. But the operation still won’t succeed. Flag-violating actions are just silently ignored in non-strict.

Here’s the same example, but the property is created from scratch:

Now let’s add a custom toString to user.

Normally, a built-in toString for objects is non-enumerable, it does not show up in for..in. But if we add a toString of our own, then by default it shows up in for..in, like this:

If we don’t like it, then we can set enumerable:false. Then it won’t appear in a for..in loop, just like the built-in one:

Non-enumerable properties are also excluded from Object.keys:

The non-configurable flag (configurable:false) is sometimes preset for built-in objects and properties.

A non-configurable property can’t be deleted, its attributes can’t be modified.

For instance, Math.PI is non-writable, non-enumerable and non-configurable:

So, a programmer is unable to change the value of Math.PI or overwrite it.

We also can’t change Math.PI to be writable again:

There’s absolutely nothing we can do with Math.PI.

Making a property non-configurable is a one-way road. We cannot change it back with defineProperty.

Please note: configurable: false prevents changes of property flags and its deletion, while allowing to change its value.

Here user.name is non-configurable, but we can still change it (as it’s writable):

And here we make user.name a “forever sealed” constant, just like the built-in Math.PI:

There’s a minor exception about changing flags.

We can change writable: true to false for a non-configurable property, thus preventing its value modification (to add another layer of protection). Not the other way around though.

There’s a method Object.defineProperties(obj, descriptors) that allows to define many properties at once.

The syntax is:

For instance:

So, we can set many properties at once.

To get all property descriptors at once, we can use the method Object.getOwnPropertyDescriptors(obj).

Together with Object.defineProperties it can be used as a “flags-aware” way of cloning an object:

Normally when we clone an object, we use an assignment to copy properties, like this:

…But that does not copy flags. So if we want a “better” clone then Object.defineProperties is preferred.

Another difference is that for..in ignores symbolic and non-enumerable properties, but Object.getOwnPropertyDescriptors returns all property descriptors including symbolic and non-enumerable ones.

Property descriptors work at the level of individual properties.

There are also methods that limit access to the whole object:

And also there are tests for them:

These methods are rarely used in practice.