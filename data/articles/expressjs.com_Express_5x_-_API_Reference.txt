Title: Express 5.x - API Reference
Source: https://expressjs.com/en/api.html

Creates an Express application. The express() function is a top-level function exported by the express module.

This is a built-in middleware function in Express. It parses incoming requests
with JSON payloads and is based on
body-parser.

Returns middleware that only parses JSON and only looks at requests where
the Content-Type header matches the type option. This parser accepts any
Unicode encoding of the body and supports automatic inflation of gzip and
deflate encodings.

A new body object containing the parsed data is populated on the request
object after the middleware (i.e. req.body), or undefined if
there was no body to parse, the Content-Type was not matched, or an error
occurred.

As req.body’s shape is based on user-controlled input, all properties and
values in this object are untrusted and should be validated before trusting.
For example, req.body.foo.toString() may fail in multiple ways, for example
foo may not be there or may not be a string, and toString may not be a
function and instead a string or other user-input.

The following table describes the properties of the optional options object.

This is a built-in middleware function in Express. It parses incoming request
payloads into a Buffer and is based on
body-parser.

Returns middleware that parses all bodies as a Buffer and only looks at requests
where the Content-Type header matches the type option. This parser accepts
any Unicode encoding of the body and supports automatic inflation of gzip and
deflate encodings.

A new body Buffer containing the parsed data is populated on the request
object after the middleware (i.e. req.body), or undefined if
there was no body to parse, the Content-Type was not matched, or an error
occurred.

As req.body’s shape is based on user-controlled input, all properties and
values in this object are untrusted and should be validated before trusting.
For example, req.body.toString() may fail in multiple ways, for example
stacking multiple parsers req.body may be from a different parser. Testing
that req.body is a Buffer before calling buffer methods is recommended.

The following table describes the properties of the optional options object.

Creates a new router object.

The optional options parameter specifies the behavior of the router.

You can add middleware and HTTP method routes (such as get, put, post, and
so on) to router just like an application.

For more information, see Router.

This is a built-in middleware function in Express.
It serves static files and is based on  serve-static.

NOTE: For best results, use a reverse proxy cache to improve performance of serving static assets.

The root argument specifies the root directory from which to serve static assets.
The function determines the file to serve by combining req.url with the provided root directory.
When a file is not found, instead of sending a 404 response, it instead calls next()
to move on to the next middleware, allowing for stacking and fall-backs.

The following table describes the properties of the options object.
See also the example below.

For more information, see Serving static files in Express.
and Using middleware - Built-in middleware.

Possible values for this option are:

When this option is true, client errors such as a bad request or a request to a non-existent
file will cause this middleware to simply call next() to invoke the next middleware in the stack.
When false, these errors (even 404s), will invoke next(err).

Set this option to true so you can map multiple physical directories
to the same web address or for routes to fill in non-existent files.

Use false if you have mounted this middleware at a path designed
to be strictly a single file system directory, which allows for short-circuiting 404s
for less overhead. This middleware will also reply to all methods.

For this option, specify a function to set custom response headers. Alterations to the headers must occur synchronously.

The signature of the function is:

Arguments:

Here is an example of using the express.static middleware function with an elaborate options object:

This is a built-in middleware function in Express. It parses incoming request
payloads into a string and is based on
body-parser.

Returns middleware that parses all bodies as a string and only looks at requests
where the Content-Type header matches the type option. This parser accepts
any Unicode encoding of the body and supports automatic inflation of gzip and
deflate encodings.

A new body string containing the parsed data is populated on the request
object after the middleware (i.e. req.body), or undefined if
there was no body to parse, the Content-Type was not matched, or an error
occurred.

As req.body’s shape is based on user-controlled input, all properties and
values in this object are untrusted and should be validated before trusting.
For example, req.body.trim() may fail in multiple ways, for example
stacking multiple parsers req.body may be from a different parser. Testing
that req.body is a string before calling string methods is recommended.

The following table describes the properties of the optional options object.

This is a built-in middleware function in Express. It parses incoming requests
with urlencoded payloads and is based on body-parser.

Returns middleware that only parses urlencoded bodies and only looks at
requests where the Content-Type header matches the type option. This
parser accepts only UTF-8 encoding of the body and supports automatic
inflation of gzip and deflate encodings.

A new body object containing the parsed data is populated on the request
object after the middleware (i.e. req.body), or undefined if
there was no body to parse, the Content-Type was not matched, or an error
occurred. This object will contain key-value pairs, where the value can be
a string or array (when extended is false), or any type (when extended
is true).

As req.body’s shape is based on user-controlled input, all properties and
values in this object are untrusted and should be validated before trusting.
For example, req.body.foo.toString() may fail in multiple ways, for example
foo may not be there or may not be a string, and toString may not be a
function and instead a string or other user-input.

The following table describes the properties of the optional options object.

The app object conventionally denotes the Express application.
Create it by calling the top-level express() function exported by the Express module:

The app object has methods for

It also has settings (properties) that affect how the application behaves;
for more information, see Application settings.

The Express application object can be referred from the request object and the response object as req.app, and res.app, respectively.

The app.locals object has properties that are local variables within the application,
and will be available in templates rendered with res.render.

The locals object is used by view engines to render a response. The object
keys may be particularly sensitive and should not contain user-controlled
input, as it may affect the operation of the view engine or provide a path to
cross-site scripting. Consult the documentation for the used view engine for
additional considerations.

Once set, the value of app.locals properties persist throughout the life of the application,
in contrast with res.locals properties that
are valid only for the lifetime of the request.

You can access local variables in templates rendered within the application.
This is useful for providing helper functions to templates, as well as application-level data.
Local variables are available in middleware via req.app.locals (see req.app)

The app.mountpath property contains one or more path patterns on which a sub-app was mounted.

A sub-app is an instance of express that may be used for handling the request to a route.

It is similar to the baseUrl property of the req object, except req.baseUrl
returns the matched URL path, instead of the matched patterns.

If a sub-app is mounted on multiple path patterns, app.mountpath returns the list of
patterns it is mounted on, as shown in the following example.

The application’s in-built instance of router. This is created lazily, on first access.

You can add middleware and HTTP method routes to the router just like an application.

For more information, see Router.

The mount event is fired on a sub-app, when it is mounted on a parent app. The parent app is passed to the callback function.

NOTE

Sub-apps will:

For details, see Application settings.

This method is like the standard app.METHOD() methods,
except it matches all HTTP verbs.

You may provide multiple callbacks that behave like middleware. These can call
                next('route') to skip remaining callbacks for the current route.
                This is useful for conditional routing logic.

If a callback throws an error or returns a rejected promise, next(err) is invoked automatically.

Since both router and app implement the middleware interface,
                they can also be used as callback middleware.

For examples, see Middleware callback function examples.

The following callback is executed for requests to /secret whether using
GET, POST, PUT, DELETE, or any other HTTP request method:

The app.all() method is useful for mapping “global” logic for specific path prefixes or arbitrary matches. For example, if you put the following at the top of all other
route definitions, it requires that all routes from that point on
require authentication, and automatically load a user. Keep in mind
that these callbacks do not have to act as end-points: loadUser
can perform a task, then call next() to continue matching subsequent
routes.

Or the equivalent:

Another example is white-listed “global” functionality.
The example is similar to the ones above, but it only restricts paths that start with
“/api”:

Routes HTTP DELETE requests to the specified path with the specified callback functions.
For more information, see the routing guide.

You may provide multiple callbacks that behave like middleware. These can call
                next('route') to skip remaining callbacks for the current route.
                This is useful for conditional routing logic.

If a callback throws an error or returns a rejected promise, next(err) is invoked automatically.

Since both router and app implement the middleware interface,
                they can also be used as callback middleware.

For examples, see Middleware callback function examples.

Sets the Boolean setting name to false, where name is one of the properties from the app settings table.
Calling app.set('foo', false) for a Boolean property is the same as calling app.disable('foo').

For example:

Returns true if the Boolean setting name is disabled (false), where name is one of the properties from
the app settings table.

Sets the Boolean setting name to true, where name is one of the properties from the app settings table.
Calling app.set('foo', true) for a Boolean property is the same as calling app.enable('foo').

Returns true if the setting name is enabled (true), where name is one of the
properties from the app settings table.

Registers the given template engine callback as ext.

By default, Express will require() the engine based on the file extension.
For example, if you try to render a “foo.pug” file, Express invokes the
following internally, and caches the require() on subsequent calls to increase
performance.

Use this method for engines that do not provide .__express out of the box,
or if you wish to “map” a different extension to the template engine.

For example, to map the EJS template engine to “.html” files:

In this case, EJS provides a .renderFile() method with
the same signature that Express expects: (path, options, callback),
though note that it aliases this method as ejs.__express internally
so if you’re using “.ejs” extensions you don’t need to do anything.

Some template engines do not follow this convention.  The
consolidate.js library maps Node template engines to follow this convention,
so they work seamlessly with Express.

Returns the value of name app setting, where name is one of the strings in the
app settings table. For example:

Routes HTTP GET requests to the specified path with the specified callback functions.

You may provide multiple callbacks that behave like middleware. These can call
                next('route') to skip remaining callbacks for the current route.
                This is useful for conditional routing logic.

If a callback throws an error or returns a rejected promise, next(err) is invoked automatically.

Since both router and app implement the middleware interface,
                they can also be used as callback middleware.

For examples, see Middleware callback function examples.

For more information, see the routing guide.

Starts a UNIX socket and listens for connections on the given path.
This method is identical to Node’s http.Server.listen().

Binds and listens for connections on the specified host and port.
This method is identical to Node’s http.Server.listen().

If port is omitted or is 0, the operating system will assign an arbitrary unused
port, which is useful for cases like automated tasks (tests, etc.).

The app returned by express() is in fact a JavaScript
Function, designed to be passed to Node’s HTTP servers as a callback
to handle requests. This makes it easy to provide both HTTP and HTTPS versions of
your app with the same code base, as the app does not inherit from these
(it is simply a callback):

The app.listen() method returns an http.Server object and (for HTTP) is a convenience method for the following:

Note

All the forms of Node’s http.Server.listen() method are in fact actually supported.

Routes an HTTP request, where METHOD is the HTTP method of the request, such as GET,
PUT, POST, and so on, in lowercase. Thus, the actual methods are app.get(),
app.post(), app.put(), and so on. See Routing methods below for the complete list.

You may provide multiple callbacks that behave like middleware. These can call
                next('route') to skip remaining callbacks for the current route.
                This is useful for conditional routing logic.

If a callback throws an error or returns a rejected promise, next(err) is invoked automatically.

Since both router and app implement the middleware interface,
                they can also be used as callback middleware.

For examples, see Middleware callback function examples.

Express supports the following routing methods corresponding to the HTTP methods of the same names:

The API documentation has explicit entries only for the most popular HTTP methods app.get(),
app.post(), app.put(), and app.delete().
However, the other methods listed above work in exactly the same way.

To route methods that translate to invalid JavaScript variable names, use the bracket notation. For example, app['m-search']('/', function ....

The app.get() function is automatically called for the HTTP HEAD method in addition to the GET
  method if app.head() was not called for the path before app.get().

The method, app.all(), is not derived from any HTTP method and loads middleware at
the specified path for all HTTP request methods.
For more information, see app.all.

For more information on routing, see the routing guide.

Add callback triggers to route parameters, where name is the name of the parameter or an array of them, and callback is the callback function. The parameters of the callback function are the request object, the response object, the next middleware, the value of the parameter and the name of the parameter, in that order.

If name is an array, the callback trigger is registered for each parameter declared in it, in the order in which they are declared. Furthermore, for each declared parameter except the last one, a call to next inside the callback will call the callback for the next declared parameter. For the last parameter, a call to next will call the next middleware in place for the route currently being processed, just like it would if name were just a string.

For example, when :user is present in a route path, you may map user loading logic to automatically provide req.user to the route, or perform validations on the parameter input.

Param callback functions are local to the router on which they are defined. They are not inherited by mounted apps or routers, nor are they triggered for route parameters inherited from parent routers. Hence, param callbacks defined on app will be triggered only by route parameters defined on app routes.

All param callbacks will be called before any handler of any route in which the param occurs, and they will each be called only once in a request-response cycle, even if the parameter is matched in multiple routes, as shown in the following examples.

On GET /user/42, the following is printed:

On GET /user/42/3, the following is printed:

Returns the canonical path of the app, a string.

The behavior of this method can become very complicated in complex cases of mounted apps:
it is usually better to use req.baseUrl to get the canonical path of the app.

Routes HTTP POST requests to the specified path with the specified callback functions.
For more information, see the routing guide.

You may provide multiple callbacks that behave like middleware. These can call
                next('route') to skip remaining callbacks for the current route.
                This is useful for conditional routing logic.

If a callback throws an error or returns a rejected promise, next(err) is invoked automatically.

Since both router and app implement the middleware interface,
                they can also be used as callback middleware.

For examples, see Middleware callback function examples.

Routes HTTP PUT requests to the specified path with the specified callback functions.

You may provide multiple callbacks that behave like middleware. These can call
                next('route') to skip remaining callbacks for the current route.
                This is useful for conditional routing logic.

If a callback throws an error or returns a rejected promise, next(err) is invoked automatically.

Since both router and app implement the middleware interface,
                they can also be used as callback middleware.

For examples, see Middleware callback function examples.

Returns the rendered HTML of a view via the callback function. It accepts an optional parameter
that is an object containing local variables for the view. It is like res.render(),
except it cannot send the rendered view to the client on its own.

Think of app.render() as a utility function for generating rendered view strings.
Internally res.render() uses app.render() to render views.

The view argument performs file system operations like reading a file from
disk and evaluating Node.js modules, and as so for security reasons should not
contain input from the end-user.

The locals object is used by view engines to render a response. The object
keys may be particularly sensitive and should not contain user-controlled
input, as it may affect the operation of the view engine or provide a path to
cross-site scripting. Consult the documentation for the used view engine for
additional considerations.

The local variable cache is reserved for enabling view cache. Set it to true, if you want to
cache view during development; view caching is enabled in production by default.

Returns an instance of a single route, which you can then use to handle HTTP verbs with optional middleware.
Use app.route() to avoid duplicate route names (and thus typo errors).

Assigns setting name to value. You may store any value that you want,
but certain names can be used to configure the behavior of the server. These
special names are listed in the app settings table.

Calling app.set('foo', true) for a Boolean property is the same as calling
app.enable('foo'). Similarly, calling app.set('foo', false) for a Boolean
property is the same as calling app.disable('foo').

Retrieve the value of a setting with app.get().

The following table lists application settings.

Note that sub-apps will:

Exceptions: Sub-apps will inherit the value of trust proxy even though it has a default value (for backward-compatibility);
Sub-apps will not inherit the value of view cache in production (when NODE_ENV is “production”).

case sensitive routing

Enable case sensitivity.
      When enabled, "/Foo" and "/foo" are different routes.
      When disabled, "/Foo" and "/foo" are treated the same.

NOTE: Sub-apps will inherit the value of this setting.

env

process.env.NODE_ENV (NODE_ENV environment variable) or “development” if NODE_ENV is not set.

etag

Set the ETag response header. For possible values, see the etag options table.

More about the HTTP ETag header.

weak

jsonp callback name

“callback”

json escape

Enable escaping JSON responses from the res.json, res.jsonp, and res.send APIs. This will escape the characters <, >, and & as Unicode escape sequences in JSON. The purpose of this is to assist with mitigating certain types of persistent XSS attacks when clients sniff responses for HTML.

NOTE: Sub-apps will inherit the value of this setting.

json replacer

NOTE: Sub-apps will inherit the value of this setting.

json spaces

NOTE: Sub-apps will inherit the value of this setting.

query parser

Disable query parsing by setting the value to false, or set the query parser to use either “simple” or “extended” or a custom query string parsing function.

The simple query parser is based on Node’s native query parser, querystring.

The extended query parser is based on qs.

A custom query string parsing function will receive the complete query string, and must return an object of query keys and their values.

strict routing

Enable strict routing.
      When enabled, the router treats "/foo" and "/foo/" as different.
      Otherwise, the router treats "/foo" and "/foo/" as the same.

NOTE: Sub-apps will inherit the value of this setting.

subdomain offset

trust proxy

Indicates the app is behind a front-facing proxy, and to use the X-Forwarded-* headers to determine the connection and the IP address of the client. NOTE: X-Forwarded-* headers are easily spoofed and the detected IP addresses are unreliable.

When enabled, Express attempts to determine the IP address of the client connected through the front-facing proxy, or series of proxies. The `req.ips` property, then contains an array of IP addresses the client is connected through. To enable it, use the values described in the trust proxy options table.

The `trust proxy` setting is implemented using the proxy-addr package. For more information, see its documentation.

NOTE: Sub-apps will inherit the value of this setting, even though it has a default value.

false (disabled)

views

process.cwd() + '/views'

view cache

Enables view template compilation caching.

NOTE: Sub-apps will not inherit the value of this setting in production (when `NODE_ENV` is "production").

true in production, otherwise undefined.

view engine

NOTE: Sub-apps will inherit the value of this setting.

x-powered-by

true

Read Express behind proxies for more
  information.

If true, the client’s IP address is understood as the left-most entry in the X-Forwarded-* header.

If false, the app is understood as directly facing the Internet and the client’s IP address is derived from req.connection.remoteAddress. This is the default setting.

An IP address, subnet, or an array of IP addresses, and subnets to trust. Pre-configured subnet names are:

Set IP addresses in any of the following ways:

Specify a single subnet:

Specify a subnet and an address:

Specify multiple subnets as CSV:

Specify multiple subnets as an array:

When specified, the IP addresses or the subnets are excluded from the address determination process, and the untrusted IP address nearest to the application server is determined as the client’s IP address.

Trust the nth hop from the front-facing proxy server as the client.

Custom trust implementation. Use this only if you know what you are doing.

NOTE:  These settings apply only to dynamic files, not static files.
The express.static middleware ignores these settings.

The ETag functionality is implemented using the
  etag package.
  For more information, see its documentation.

true enables weak ETag. This is the default setting.
false disables ETag altogether.

Custom ETag function implementation. Use this only if you know what you are doing.

Mounts the specified middleware function or functions
at the specified path:
the middleware function is executed when the base of the requested path matches path.

You may provide multiple callbacks that behave like middleware. These can call
                next('route') to skip remaining callbacks for the current route.
                This is useful for conditional routing logic.

If a callback throws an error or returns a rejected promise, next(err) is invoked automatically.

Since both router and app implement the middleware interface,
                they can also be used as callback middleware.

For examples, see Middleware callback function examples.

A route will match any path that follows its path immediately with a “/”.
For example: app.use('/apple', ...) will match “/apple”, “/apple/images”,
“/apple/images/news”, and so on.

Since path defaults to “/”, middleware mounted without a path will be executed for every request to the app.
For example, this middleware function will be executed for every request to the app:

NOTE

Sub-apps will:

For details, see Application settings.

Middleware functions are executed sequentially, therefore the order of middleware inclusion is important.

Error-handling middleware

Error-handling middleware always takes four arguments. You must provide four arguments to identify it as an error-handling middleware function. Even if you don’t need to use the next object, you must specify it to maintain the signature. Otherwise, the next object will be interpreted as regular middleware and will fail to handle errors. For details about error-handling middleware, see: Error handling.

Define error-handling middleware functions in the same way as other middleware functions, except with four arguments instead of three, specifically with the signature (err, req, res, next)):

The following table provides some simple examples of valid path values for
mounting middleware.

Matches the exact path /abcd and any sub-paths starting with /abcd/ (for example, /abcd/foo):

This will match paths starting with /abcd and /abd:

This will match paths starting with /abc and /xyz:

This will match paths starting with /abcd, /xyza, /lmn, and /pqr:

The following table provides some simple examples of middleware functions that
can be used as the callback argument to app.use(), app.METHOD(), and app.all().

You can define and mount a middleware function locally.

A router is valid middleware.

An Express app is valid middleware.

You can specify more than one middleware function at the same mount path.

Use an array to group middleware logically.

You can combine all the above ways of mounting middleware.

Following are some examples of using the express.static
middleware in an Express app.

Serve static content for the app from the “public” directory in the application directory:

Mount the middleware at “/static” to serve static content only when their request path is prefixed with “/static”:

Disable logging for static content requests by loading the logger middleware after the static middleware:

Serve static files from multiple directories, but give precedence to “./public” over the others:

The req object represents the HTTP request and has properties for the
request query string, parameters, body, HTTP headers, and so on. In this documentation and by convention,
the object is always referred to as req (and the HTTP response is res) but its actual name is determined
by the parameters to the callback function in which you’re working.

For example:

But you could just as well have:

The req object is an enhanced version of Node’s own request object
and supports all built-in fields and methods.

In Express 4, req.files is no longer available on the req object by default. To access uploaded files
on the req.files object, use multipart-handling middleware like busboy, multer,
formidable,
multiparty,
connect-multiparty,
or pez.

This property holds a reference to the instance of the Express application that is using the middleware.

If you follow the pattern in which you create a module that just exports a middleware function
and require() it in your main file, then the middleware can access the Express instance via req.app

For example:

The URL path on which a router instance was mounted.

The req.baseUrl property is similar to the mountpath property of the app object,
except app.mountpath returns the matched path pattern(s).

For example:

Even if you use a path pattern or a set of path patterns to load the router,
the baseUrl property returns the matched string, not the pattern(s). In the
following example, the greet router is loaded on two path patterns.

When a request is made to /greet/jp, req.baseUrl is “/greet”. When a request is
made to /hello/jp, req.baseUrl is “/hello”.

Contains key-value pairs of data submitted in the request body.
By default, it is undefined, and is populated when you use body-parsing middleware such
as express.json() or express.urlencoded().

As req.body’s shape is based on user-controlled input, all properties and values in this object are untrusted and should be validated before trusting. For example, req.body.foo.toString() may fail in multiple ways, for example foo may not be there or may not be a string, and toString may not be a function and instead a string or other user-input.

The following example shows how to use body-parsing middleware to populate req.body.

When using cookie-parser middleware, this property is an object that
contains cookies sent by the request. If the request contains no cookies, it defaults to {}.

If the cookie has been signed, you have to use req.signedCookies.

For more information, issues, or concerns, see cookie-parser.

When the response is still “fresh” in the client’s cache true is returned, otherwise false is returned to indicate that the client cache is now stale and the full response should be sent.

When a client sends the Cache-Control: no-cache request header to indicate an end-to-end reload request, this module will return false to make handling these requests transparent.

Further details for how cache validation works can be found in the
HTTP/1.1 Caching Specification.

Contains the host derived from the Host HTTP header.

When the trust proxy setting
does not evaluate to false, this property will instead get the value
from the X-Forwarded-Host header field. This header can be set by
the client or by the proxy.

If there is more than one X-Forwarded-Host header in the request, the
value of the first header is used. This includes a single header with
comma-separated values, in which the first value is used.

Contains the hostname derived from the Host HTTP header.

When the trust proxy setting
does not evaluate to false, this property will instead get the value
from the X-Forwarded-Host header field. This header can be set by
the client or by the proxy.

If there is more than one X-Forwarded-Host header in the request, the
value of the first header is used. This includes a single header with
comma-separated values, in which the first value is used.

Prior to Express v4.17.0, the X-Forwarded-Host could not contain multiple
values or be present more than once.

Contains the remote IP address of the request.

When the trust proxy setting does not evaluate to false,
the value of this property is derived from the left-most entry in the
X-Forwarded-For header. This header can be set by the client or by the proxy.

When the trust proxy setting does not evaluate to false,
this property contains an array of IP addresses
specified in the X-Forwarded-For request header. Otherwise, it contains an
empty array. This header can be set by the client or by the proxy.

For example, if X-Forwarded-For is client, proxy1, proxy2, req.ips would be
["client", "proxy1", "proxy2"], where proxy2 is the furthest downstream.

Contains a string corresponding to the HTTP method of the request:
GET, POST, PUT, and so on.

req.url is not a native Express property, it is inherited from Node’s http module.

This property is much like req.url; however, it retains the original request URL,
allowing you to rewrite req.url freely for internal routing purposes. For example,
the “mounting” feature of app.use() will rewrite req.url to strip the mount point.

req.originalUrl is available both in middleware and router objects, and is a
combination of req.baseUrl and req.url. Consider following example:

This property is an object containing properties mapped to the named route “parameters”. For example, if you have the route /user/:name, then the “name” property is available as req.params.name. This object defaults to Object.create(null) when using string paths, but remains a standard object with a normal prototype when the path is defined with a regular expression.

Properties corresponding to wildcard parameters are arrays containing separate path segments split on /:

When you use a regular expression for the route definition, capture groups are provided as integer keys using req.params[n], where n is the nth capture group.

Named capturing groups in regular expressions behave like named route parameters. For example the group from /^\/file\/(?<path>.*)$/ expression is available as req.params.path.

If you need to make changes to a key in req.params, use the app.param handler. Changes are applicable only to parameters already defined in the route path.

Any changes made to the req.params object in a middleware or route handler will be reset.

Note

Express automatically decodes the values in req.params (using decodeURIComponent).

Contains the path part of the request URL.

When called from a middleware, the mount point is not included in req.path. See app.use() for more details.

Contains the request protocol string: either http or (for TLS requests) https.

When the trust proxy setting does not evaluate to false,
this property will use the value of the X-Forwarded-Proto header field if present.
This header can be set by the client or by the proxy.

This property is an object containing a property for each query string parameter in the route.
When query parser is set to disabled, it is an empty object {}, otherwise it is the result of the configured query parser.

As req.query’s shape is based on user-controlled input, all properties and values in this object are untrusted and should be validated before trusting. For example, req.query.foo.toString() may fail in multiple ways, for example foo may not be there or may not be a string, and toString may not be a function and instead a string or other user-input.

The value of this property can be configured with the query parser application setting to work how your application needs it. A very popular query string parser is the qs module, and this is used by default. The qs module is very configurable with many settings, and it may be desirable to use different settings than the default to populate req.query:

Check out the query parser application setting documentation for other customization options.

This property holds a reference to the response object
that relates to this request object.

Contains the currently-matched route, a string. For example:

Example output from the previous snippet:

A Boolean property that is true if a TLS connection is established. Equivalent to the following:

When using cookie-parser middleware, this property
contains signed cookies sent by the request, unsigned and ready for use. Signed cookies reside
in a different object to show developer intent; otherwise, a malicious attack could be placed on
req.cookie values (which are easy to spoof). Note that signing a cookie does not make it “hidden”
or encrypted; but simply prevents tampering (because the secret used to sign is private).

If no signed cookies are sent, the property defaults to {}.

For more information, issues, or concerns, see cookie-parser.

Indicates whether the request is “stale,” and is the opposite of req.fresh.
For more information, see req.fresh.

An array of subdomains in the domain name of the request.

The application property subdomain offset, which defaults to 2, is used for determining the
beginning of the subdomain segments. To change this behavior, change its value
using app.set.

A Boolean property that is true if the request’s X-Requested-With header field is
“XMLHttpRequest”, indicating that the request was issued by a client library such as jQuery.

Checks if the specified content types are acceptable, based on the request’s Accept HTTP header field.
The method returns the best match, or if none of the specified content types is acceptable, returns
false (in which case, the application should respond with 406 "Not Acceptable").

The type value may be a single MIME type string (such as “application/json”),
an extension name such as “json”, a comma-delimited list, or an array. For a
list or array, the method returns the best match (if any).

For more information, or if you have issues or concerns, see accepts.

Returns the first accepted charset of the specified character sets,
based on the request’s Accept-Charset HTTP header field.
If none of the specified charsets is accepted, returns false.

For more information, or if you have issues or concerns, see accepts.

Returns the first accepted encoding of the specified encodings,
based on the request’s Accept-Encoding HTTP header field.
If none of the specified encodings is accepted, returns false.

For more information, or if you have issues or concerns, see accepts.

Returns the first accepted language of the specified languages,
based on the request’s Accept-Language HTTP header field.
If none of the specified languages is accepted, returns false.

If no lang argument is given, then req.acceptsLanguages()
returns all languages from the HTTP Accept-Language header
as an Array.

For more information, or if you have issues or concerns, see accepts.

Express (5.x) source: request.js line 172

Accepts (2.0) source: index.js line 195

Returns the specified HTTP request header field (case-insensitive match).
The Referrer and Referer fields are interchangeable.

Aliased as req.header(field).

Returns the matching content type if the incoming request’s “Content-Type” HTTP header field
matches the MIME type specified by the type parameter. If the request has no body, returns null.
Returns false otherwise.

For more information, or if you have issues or concerns, see type-is.

Range header parser.

The size parameter is the maximum size of the resource.

The options parameter is an object that can have the following properties.

An array of ranges will be returned or negative numbers indicating an error parsing.

The res object represents the HTTP response that an Express app sends when it gets an HTTP request.

In this documentation and by convention,
the object is always referred to as res (and the HTTP request is req) but its actual name is determined
by the parameters to the callback function in which you’re working.

For example:

But you could just as well have:

The res object is an enhanced version of Node’s own response object
and supports all built-in fields and methods.

This property holds a reference to the instance of the Express application that is using the middleware.

res.app is identical to the req.app property in the request object.

Boolean property that indicates if the app sent HTTP headers for the response.

Use this property to set variables accessible in templates rendered with res.render.
The variables set on res.locals are available within a single request-response cycle, and will not
be shared between requests.

The locals object is used by view engines to render a response. The object
keys may be particularly sensitive and should not contain user-controlled
input, as it may affect the operation of the view engine or provide a path to
cross-site scripting. Consult the documentation for the used view engine for
additional considerations.

In order to keep local variables for use in template rendering between requests, use
app.locals instead.

This property is useful for exposing request-level information such as the request path name,
authenticated user, user settings, and so on to templates rendered within the application.

This property holds a reference to the request object
that relates to this response object.

res.append() is supported by Express v4.11.0+

Appends the specified value to the HTTP response header field.  If the header is not already set,
it creates the header with the specified value. The value parameter can be a string or an array.

Note

calling res.set() after res.append() will reset the previously-set header value.

Sets the HTTP response Content-Disposition header field to “attachment”. If a filename is given,
then it sets the Content-Type based on the extension name via res.type(),
and sets the Content-Disposition “filename=” parameter.

Sets cookie name to value.  The value parameter may be a string or object converted to JSON.

The options parameter is an object that can have the following properties.

All res.cookie() does is set the HTTP Set-Cookie header with the options provided.
Any option not specified defaults to the value stated in RFC 6265.

For example:

You can set multiple cookies in a single response by calling res.cookie multiple times, for example:

The encode option allows you to choose the function used for cookie value encoding.
Does not support asynchronous functions.

Example use case: You need to set a domain-wide cookie for another site in your organization.
This other site (not under your administrative control) does not use URI-encoded cookie values.

The maxAge option is a convenience option for setting “expires” relative to the current time in milliseconds.
The following is equivalent to the second example above.

You can pass an object as the value parameter; it is then serialized as JSON and parsed by bodyParser() middleware.

When using cookie-parser middleware, this method also
supports signed cookies. Simply include the signed option set to true.
Then, res.cookie() will use the secret passed to cookieParser(secret) to sign the value.

Later, you may access this value through the req.signedCookies object.

Clears the cookie with the specified name by sending a Set-Cookie header that sets its expiration date in the past.
This instructs the client that the cookie has expired and is no longer valid. For more information
about available options, see res.cookie().

The expires and max-age options are being ignored completely.

Web browsers and other compliant clients will only clear the cookie if the given
options is identical to those given to res.cookie()

The optional options argument is supported by Express v4.16.0 onwards.

Transfers the file at path as an “attachment”. Typically, browsers will prompt the user for download.
By default, the Content-Disposition header “filename=” parameter is derived from the path argument, but can be overridden with the filename parameter.
If path is relative, then it will be based on the current working directory of the process or
the root option, if provided.

This API provides access to data on the running file system. Ensure that either (a) the way in
which the path argument was constructed is secure if it contains user input or (b) set the root
option to the absolute path of a directory to contain access within.

When the root option is provided, Express will validate that the relative path provided as
path will resolve within the given root option.

The following table provides details on the options parameter.

The optional options argument is supported by Express v4.16.0 onwards.

The method invokes the callback function fn(err) when the transfer is complete
or when an error occurs. If the callback function is specified and an error occurs,
the callback function must explicitly handle the response process either by
ending the request-response cycle, or by passing control to the next route.

Ends the response process. This method actually comes from Node core, specifically the response.end() method of http.ServerResponse.

Use to quickly end the response without any data. If you need to respond with data, instead use methods such as res.send() and res.json().

Performs content-negotiation on the Accept HTTP header on the request object, when present.
It uses req.accepts() to select a handler for the request, based on the acceptable
types ordered by their quality values. If the header is not specified, the first callback is invoked.
When no match is found, the server responds with 406 “Not Acceptable”, or invokes the default callback.

The Content-Type response header is set when a callback is selected. However, you may alter
this within the callback using methods such as res.set() or res.type().

The following example would respond with { "message": "hey" } when the Accept header field is set
to “application/json” or “*/json” (however, if it is “*/*”, then the response will be “hey”).

In addition to canonicalized MIME types, you may also use extension names mapped
to these types for a slightly less verbose implementation:

Returns the HTTP response header specified by field.
The match is case-insensitive.

Sends a JSON response. This method sends a response (with the correct content-type) that is the parameter converted to a 
JSON string using JSON.stringify().

The parameter can be any JSON type, including object, array, string, Boolean, number, or null,
and you can also use it to convert other values to JSON.

Sends a JSON response with JSONP support. This method is identical to res.json(),
except that it opts-in to JSONP callback support.

By default, the JSONP callback name is simply callback. Override this with the
jsonp callback name setting.

The following are some examples of JSONP responses using the same code:

Joins the links provided as properties of the parameter to populate the response’s
Link HTTP header field.

For example, the following call:

Yields the following results:

Sets the response Location HTTP header to the specified path parameter.

After encoding the URL, if not encoded already, Express passes the specified URL to the browser in the Location header,
without any validation.

Browsers take the responsibility of deriving the intended URL from the current URL
or the referring URL, and the URL specified in the Location header; and redirect the user accordingly.

Redirects to the URL derived from the specified path, with specified status, a positive integer
that corresponds to an HTTP status code.
If not specified, status defaults to 302 "Found".

Redirects can be a fully-qualified URL for redirecting to a different site:

Redirects can be relative to the root of the host name. For example, if the
application is on http://example.com/admin/post/new, the following
would redirect to the URL http://example.com/admin:

Redirects can be relative to the current URL. For example,
from http://example.com/blog/admin/ (notice the trailing slash), the following
would redirect to the URL http://example.com/blog/admin/post/new.

Redirecting to post/new from http://example.com/blog/admin (no trailing slash),
will redirect to http://example.com/blog/post/new.

If you found the above behavior confusing, think of path segments as directories
(with trailing slashes) and files, it will start to make sense.

Path-relative redirects are also possible. If you were on
http://example.com/admin/post/new, the following would redirect to
http://example.com/admin/post:

See also Security best practices: Prevent open redirect 
vulnerabilities.

Renders a view and sends the rendered HTML string to the client.
Optional parameters:

The view argument is a string that is the file path of the view file to render. This can be an absolute path, or a path relative to the views setting. If the path does not contain a file extension, then the view engine setting determines the file extension. If the path does contain a file extension, then Express will load the module for the specified template engine (via require()) and render it using the loaded module’s __express function.

For more information, see Using template engines with Express.

Warning

The view argument performs file system operations like reading a file from disk and evaluating Node.js modules, and as so for security reasons should not contain input from the end-user.

Warning

The locals object is used by view engines to render a response. The object
keys may be particularly sensitive and should not contain user-controlled
input, as it may affect the operation of the view engine or provide a path to
cross-site scripting. Consult the documentation for the used view engine for
additional considerations.

Caution

The local variable cache enables view caching. Set it to true,
to cache the view during development; view caching is enabled in production by default.

Sends the HTTP response.

The body parameter can be a Buffer object, a String, an object, Boolean, or an Array.
For example:

This method performs many useful tasks for simple non-streaming responses:
For example, it automatically assigns the Content-Length HTTP response header field 
and provides automatic HEAD and HTTP cache freshness support.

When the parameter is a Buffer object, the method sets the Content-Type
response header field to “application/octet-stream”, unless previously defined as shown below:

When the parameter is a String, the method sets the Content-Type to “text/html”:

When the parameter is an Array or Object, Express responds with the JSON representation:

res.sendFile() is supported by Express v4.8.0 onwards.

Transfers the file at the given path. Sets the Content-Type response HTTP header field
based on the filename’s extension. Unless the root option is set in
the options object, path must be an absolute path to the file.

This API provides access to data on the running file system. Ensure that either (a) the way in
which the path argument was constructed into an absolute path is secure if it contains user
input or (b) set the root option to the absolute path of a directory to contain access within.

When the root option is provided, the path argument is allowed to be a relative path,
including containing ... Express will validate that the relative path provided as path will
resolve within the given root option.

The following table provides details on the options parameter.

The method invokes the callback function fn(err) when the transfer is complete
or when an error occurs. If the callback function is specified and an error occurs,
the callback function must explicitly handle the response process either by
ending the request-response cycle, or by passing control to the next route.

Here is an example of using res.sendFile with all its arguments.

The following example illustrates using
res.sendFile to provide fine-grained support for serving files:

For more information, or if you have issues or concerns, see send.

Sets the response HTTP status code to statusCode and sends the registered status message as the text response body. If an unknown status code is specified, the response body will just be the code number.

Some versions of Node.js will throw when res.statusCode is set to an
invalid HTTP status code (outside of the range 100 to 599). Consult
the HTTP server documentation for the Node.js version being used.

More about HTTP Status Codes

Sets the response’s HTTP header field to value.
To set multiple fields at once, pass an object as the parameter.

Aliased as res.header(field [, value]).

Sets the HTTP status for the response.
It is a chainable alias of Node’s response.statusCode.

Sets the Content-Type HTTP header to the MIME type as determined by the specified type. If type contains the “/” character, then it sets the Content-Type to the exact value of type, otherwise it is assumed to be a file extension and the MIME type is looked up using the contentType() method of the mime-types package.

Aliased as res.contentType(type).

Adds the field to the Vary response header, if it is not there already.

A router object is an instance of middleware and routes. You can think of it
as a “mini-application,” capable only of performing middleware and routing
functions. Every Express application has a built-in app router.

A router behaves like middleware itself, so you can use it as an argument to
app.use() or as the argument to another router’s use() method.

The top-level express object has a Router() method that creates a new router object.

Once you’ve created a router object, you can add middleware and HTTP method routes (such as get, put, post,
and so on) to it just like an application. For example:

You can then use a router for a particular root URL in this way separating your routes into files or even mini-apps.

Keep in mind that any middleware applied to a router will run for all requests on that router’s path, even those that aren’t part of the router.

This method is just like the router.METHOD() methods, except that it matches all HTTP methods (verbs).

This method is extremely useful for
mapping “global” logic for specific path prefixes or arbitrary matches.
For example, if you placed the following route at the top of all other
route definitions, it would require that all routes from that point on
would require authentication, and automatically load a user. Keep in mind
that these callbacks do not have to act as end points; loadUser
can perform a task, then call next() to continue matching subsequent
routes.

Or the equivalent:

Another example of this is white-listed “global” functionality. Here,
the example is much like before, but it only restricts paths prefixed with
“/api”:

The router.METHOD() methods provide the routing functionality in Express,
where METHOD is one of the HTTP methods, such as GET, PUT, POST, and so on,
in lowercase. Thus, the actual methods are router.get(), router.post(),
router.put(), and so on.

The router.get() function is automatically called for the HTTP HEAD method in
  addition to the GET method if router.head() was not called for the
  path before router.get().

You can provide multiple callbacks, and all are treated equally, and behave just
like middleware, except that these callbacks may invoke next('route')
to bypass the remaining route callback(s). You can use this mechanism to perform
pre-conditions on a route then pass control to subsequent routes when there is no
reason to proceed with the route matched.

The following snippet illustrates the most simple route definition possible.
Express translates the path strings to regular expressions, used internally
to match incoming requests. Query strings are not considered when performing
these matches, for example “GET /” would match the following route, as would
“GET /?name=tobi”.

You can also use regular expressions—useful if you have very specific
constraints, for example the following would match “GET /commits/71dbb9c” as well
as “GET /commits/71dbb9c..4c084f9”.

You can use next primitive to implement a flow control between different
middleware functions, based on a specific program state. Invoking next with
the string 'router' will cause all the remaining route callbacks on that router
to be bypassed.

The following example illustrates next('router') usage.

Adds callback triggers to route parameters, where name is the name of the parameter and callback is the callback function. Although name is technically optional, using this method without it is deprecated starting with Express v4.11.0 (see below).

The parameters of the callback function are:

Unlike app.param(), router.param() does not accept an array of route parameters.

For example, when :user is present in a route path, you may map user loading logic to automatically provide req.user to the route, or perform validations on the parameter input.

Param callback functions are local to the router on which they are defined. They are not inherited by mounted apps or routers, nor are they triggered for route parameters inherited from parent routers. Hence, param callbacks defined on router will be triggered only by route parameters defined on router routes.

A param callback will be called only once in a request-response cycle, even if the parameter is matched in multiple routes, as shown in the following examples.

On GET /user/42, the following is printed:

Returns an instance of a single route which you can then use to handle HTTP verbs
with optional middleware. Use router.route() to avoid duplicate route naming and
thus typing errors.

Building on the router.param() example above, the following code shows how to use
router.route() to specify various HTTP method handlers.

This approach re-uses the single /users/:user_id path and adds handlers for
various HTTP methods.

Note

When you use router.route(), middleware ordering is based on when the route is created, not when method handlers are added to the route. For this purpose, you can consider method handlers to belong to the route to which they were added.

Uses the specified middleware function or functions, with optional mount path path, that defaults to “/”.

This method is similar to app.use(). A simple example and use case is described below.
See app.use() for more information.

Middleware is like a plumbing pipe: requests start at the first middleware function defined
and work their way “down” the middleware stack processing for each path they match.

The “mount” path is stripped and is not visible to the middleware function.
The main effect of this feature is that a mounted middleware function may operate without
code changes regardless of its “prefix” pathname.

The order in which you define middleware with router.use() is very important.
They are invoked sequentially, thus the order defines middleware precedence. For example,
usually a logger is the very first middleware you would use, so that every request gets logged.

Now suppose you wanted to ignore logging requests for static files, but to continue
logging routes and middleware defined after logger().  You would simply move the call to express.static() to the top,
before adding the logger middleware:

Another example is serving files from multiple directories,
giving precedence to “./public” over the others:

The router.use() method also supports named parameters so that your mount points
for other routers can benefit from preloading using named parameters.

NOTE: Although these middleware functions are added via a particular router, when
they run is defined by the path they are attached to (not the router). Therefore,
middleware added via one router may run for other routers if its routes
match. For example, this code shows two different routers mounted on the same path:

Even though the authentication middleware was added via the authRouter it will run on the routes defined by the openRouter as well since both routers were mounted on /users. To avoid this behavior, use different paths for each router.