Title: Class checking: "instanceof"
Source: https://javascript.info/instanceof

The instanceof operator allows to check whether an object belongs to a certain class. It also takes inheritance into account.

Such a check may be necessary in many cases. For example, it can be used for building a polymorphic function, the one that treats arguments differently depending on their type.

The syntax is:

It returns true if obj belongs to the Class or a class inheriting from it.

For instance:

It also works with constructor functions:

…And with built-in classes like Array:

Please note that arr also belongs to the Object class. That’s because Array prototypically inherits from Object.

Normally, instanceof examines the prototype chain for the check. We can also set a custom logic in the static method Symbol.hasInstance.

The algorithm of obj instanceof Class works roughly as follows:

If there’s a static method Symbol.hasInstance, then just call it: Class[Symbol.hasInstance](obj). It should return either true or false, and we’re done. That’s how we can customize the behavior of instanceof.

For example:

Most classes do not have Symbol.hasInstance. In that case, the standard logic is used: obj instanceof Class checks whether Class.prototype is equal to one of the prototypes in the obj prototype chain.

In other words, compare one after another:

In the example above rabbit.__proto__ === Rabbit.prototype, so that gives the answer immediately.

In the case of an inheritance, the match will be at the second step:

Here’s the illustration of what rabbit instanceof Animal compares with Animal.prototype:

By the way, there’s also a method objA.isPrototypeOf(objB), that returns true if objA is somewhere in the chain of prototypes for objB. So the test of obj instanceof Class can be rephrased as Class.prototype.isPrototypeOf(obj).

It’s funny, but the Class constructor itself does not participate in the check! Only the chain of prototypes and Class.prototype matters.

That can lead to interesting consequences when a prototype property is changed after the object is created.

Like here:

We already know that plain objects are converted to string as [object Object]:

That’s their implementation of toString. But there’s a hidden feature that makes toString actually much more powerful than that. We can use it as an extended typeof and an alternative for instanceof.

Sounds strange? Indeed. Let’s demystify.

By specification, the built-in toString can be extracted from the object and executed in the context of any other value. And its result depends on that value.

Let’s demonstrate:

Here we used call as described in the chapter Decorators and forwarding, call/apply to execute the function objectToString in the context this=arr.

Internally, the toString algorithm examines this and returns the corresponding result. More examples:

The behavior of Object toString can be customized using a special object property Symbol.toStringTag.

For instance:

For most environment-specific objects, there is such a property. Here are some browser specific examples:

As you can see, the result is exactly Symbol.toStringTag (if exists), wrapped into [object ...].

At the end we have “typeof on steroids” that not only works for primitive data types, but also for built-in objects and even can be customized.

We can use {}.toString.call instead of instanceof for built-in objects when we want to get the type as a string rather than just to check.

Let’s summarize the type-checking methods that we know:

As we can see, {}.toString is technically a “more advanced” typeof.

And instanceof operator really shines when we are working with a class hierarchy and want to check for the class taking into account inheritance.